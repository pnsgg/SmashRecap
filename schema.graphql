"""
Specify a query to be read from gql-public. Will use the configured cacheAge on
the query resolve configuration, or the override value passed through the
directive as publicCache(cacheAge: INT) argument.
"""
directive @publicCache(
  """Optional override for the query-level cacheAge value, in seconds."""
  cacheAge: Int
) on FIELD

"""
Specify a field to only be included in the response if the user is logged in.
"""
directive @userData on FIELD

type Query {
  """Returns user address"""
  address(userId: ID!, type: String!): Address
  availableWidgets(profileType: String!): [ProfileWidget]

  """Returns a card"""
  card(externalId: ID): Card

  """Paginated, filterable list of cards"""
  cards(query: CardPaginationQuery!): CardConnection
  contentRows(profileType: String!, profileSlug: String, profileId: ID, page: String): [ProfileContentRow]

  """Returns the authenticated user"""
  currentUser: User

  """Returns a Deck"""
  deck(id: ID!): Deck

  """Returns a list of emailCategories"""
  emailCategories: [EmailCategory]

  """Returns a list of emailTypes"""
  emailTypes: [EmailType]

  """Returns an entrant given its id"""
  entrant(id: ID!): Entrant

  """Paginated, filterable list of entrants"""
  entrants(query: EntrantPaginationQuery!): EntrantConnection

  """Returns an event given its id or slug"""
  event(id: ID, slug: String): Event

  """Returns an event check in group given its id"""
  eventCheckInGroup(id: ID!): EventCheckInGroup

  """Returns a event seed given its id"""
  eventSeed(id: ID): EventSeed

  """Returns a Game given its id"""
  game(id: ID!): Game

  """Returns a paginated list of Games"""
  games(query: PaginatedGamesQuery): GameConnection

  """Get a hub by id or slug"""
  hub(id: ID, slug: String): Hub

  """Paginated, filterable list of hubs"""
  hubs(query: HubPaginationQuery): HubConnection

  """Returns an iteration given an id"""
  iteration(id: ID!): RankingIteration

  """Returns a league given its id or slug"""
  league(id: ID, slug: String): League

  """Paginated, filterable list of leagues"""
  leagues(query: LeagueQuery!): LeagueConnection

  """Get an application by id"""
  oauthApplication(id: ID!): AuthClient

  """List of scopes"""
  oauthScopes(ids: [ID]): [AuthScope]

  """Returns an array of EntityOptions"""
  options(entityType: String!): [Option]

  """Returns a participant given its id"""
  participant(id: ID!, isAdmin: Boolean): Participant

  """Returns a phase given its id"""
  phase(id: ID): Phase

  """Returns a phase group given its id"""
  phaseGroup(id: ID): PhaseGroup

  """Returns a player given an id"""
  player(id: ID!): Player

  """Returns a player rank given an id"""
  playerRank(id: ID!): PlayerRank

  """Paginated, filterable list of players"""
  players(query: PlayerQuery!): PlayerConnection
  profile(profileType: String!, profileSlug: String, profileId: ID): Profile

  """Deprecated"""
  profileAuthorization(id: ID, type: AuthorizationType, profileType: String, profileId: ID): ProfileAuthorization @deprecated(reason: "Use User.profileAuthorization")
  profileId(profileType: String!, profileSlug: String!): ID
  profileNav(profileType: String!, profileSlug: String, profileId: ID, isAdmin: Boolean, bustCache: Int): ProfileNav
  profileTasks(profileType: String!, profileId: ID!, systemIds: [ID], activeOnly: Boolean, showDismissed: Boolean, minPriority: Int): [Task]
  profileTranslations(profileType: String!, profileId: Int!): JSON
  profileWidgetPageLayout(profileType: String!, profileId: Int!, page: String!): ProfileWidgetPageLayout

  """Returns a list of regions, sorted by country"""
  regions: [Region]

  """Paginated, filterable list of ScheduleItems"""
  schedule(profileType: String!, profileId: ID, profileSlug: String, query: ScheduleQuery): LegacyScheduleItemConnection

  """Returns a phase seed given its id"""
  seed(id: ID): Seed

  """Returns an array of EntityOptionSelections"""
  selections(userId: ID!, entityType: String!): [Selection]

  """Returns a series given an id or slug"""
  series(id: ID, slug: String): RankingSeries

  """Returns a set given its id"""
  set(id: ID!): Set

  """Returns a set slot given its id"""
  setSlot(id: ID!): SetSlot

  """Returns a paginated list of Sets"""
  sets(
    page: Int
    perPage: Int

    """How to sort these sets"""
    sortType: SetSortType

    """Supported filter options to filter down set results."""
    filters: SetFilters
  ): SetConnection

  """A shop entity"""
  shop(id: ID, slug: String): Shop

  """A shop level entity"""
  shopLevel(id: ID): ShopLevel

  """A shop product"""
  shopProduct(id: ID): ShopProduct

  """The availability state of a short slug"""
  slugAvailability(tournamentId: ID!, shortSlug: String): SlugAvailability

  """Returns a standing given a standingId"""
  standing(id: ID!): Standing

  """
  Returns a standing group given its container type and id, or its id directly
  """
  standingGroup(containerType: String, containerId: ID, id: ID): StandingGroup

  """Returns an station given its id"""
  station(id: ID!): Stations

  """Returns the CSV column definitions of the status update API call"""
  statusUpdateCsvConfig: CSVConfig

  """Returns an stream given its id"""
  stream(id: ID!): Streams

  """Returns all the stream queues for a given tournament"""
  streamQueue(tournamentId: ID!, includePlayerStreams: Boolean): [StreamQueue]

  """Returns a task for the current user"""
  task(id: ID!): Task @deprecated(reason: "Not yet implemented to fetch by ID. Use \"userTasks\" resolvers on specific domain objects instead for now")

  """Returns a team given its id"""
  team(id: ID, slug: String, inviteCode: String): Team

  """Paginated, filterable list of teams"""
  teams(query: TeamsPaginationQuery!): TeamConnection

  """Returns a team given its id"""
  test(id: ID!): Test

  """Returns the top games for the past 30 days by number of registrants"""
  topGames: [Videogame]
  topLevelNav(profileType: String!, profileSlug: String, profileId: ID, isAdmin: Boolean, bustCache: Int): TopLevelNav

  """Returns a tournament given its id or slug"""
  tournament(id: ID, slug: String): Tournament

  """Paginated, filterable list of tournaments"""
  tournaments(query: TournamentQuery!): TournamentConnection

  """Returns the CSV column definitions of the tracking update API call"""
  trackingUpdateCsvConfig: CSVConfig

  """Returns an unclaimed user given a user hash"""
  unclaimedUser(hash: String!, tournamentId: ID): JSON

  """
  List of upcoming Events for the logged in User. Returns null if not logged in
  """
  upcomingEvents(
    """
    Maximum number of Events to return. Limit 100. This resource is not paginated, that is TBD if needed.
    """
    limit: Int

    """Filter upcoming Events by Tournament"""
    tournamentId: ID

    """
    Filter Events by in-person/online. Omit this argument to return BOTH in-person and online Events.
    """
    isOnline: Boolean

    """
    Filter by Events for which the User is an owner. Defaults to true, i.e.
    return Events user owns AND Events the user is participating in.
    """
    userIsOwner: Boolean = true
  ): [Event]

  """Returns a user given a user slug of the form user/abc123, or id"""
  user(id: ID, slug: String): User

  """Returns an array of EntityOptionValues"""
  values(entityType: String!): [Value]

  """Returns a videogame given its id"""
  videogame(id: ID, slug: String): Videogame

  """Returns paginated list of videogames matching the search criteria."""
  videogames(query: VideogameQuery!): VideogameConnection

  """Returns a list of votes for a user"""
  votes(userId: ID!): [Votes]
}

"""A user's address"""
type Address {
  id: ID
  address: String
  address2: String
  city: String
  country: String
  countryId: Int
  createdAt: Timestamp
  nameFirst: String
  nameLast: String
  overrideAddress: Boolean
  phoneNumber: String
  state: String
  stateId: Int
  type: String
  updatedAt: Timestamp
  userId: Int @deprecated(reason: "use User instead")
  zipcode: String
}

"""
Represents a Unix Timestamp. Supports up to 53 bit int values,
		as that is JavaScript's internal memory allocation for integer values.
"""
scalar Timestamp

"""specification for a widget that can be placed on profile pages"""
type ProfileWidget {
  """All of the fields for the widget configuration form"""
  configGqlFields: [String]
  id: String
  defaultConfig: JSON
  description: String
  disableAdd: Boolean
  icon: String
  name: String
  supportedLayouts: [String]
  widgetComponentsNodeModule: String
}

"""
The `JSON` scalar type represents JSON values as specified by
		[ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""Cards for a deck of a participant/entrant"""
type Card {
  id: ID

  """The character id associated with this card."""
  characterId: Int

  """The description of the card."""
  description: String

  """External ID from external source associated with this card."""
  externalId: String

  """External API from which the card is derived from."""
  externalSource: String
  images(type: String): [Image]

  """Additional card information, such as type, cost, rarity, etc."""
  metadata: JSON

  """The name of the card."""
  name: String
}

"""An image"""
type Image {
  id: ID
  entity: String
  entityId: Int
  height: Float
  isOriginal: Boolean
  ratio: Float
  type: String
  uploadedBy: Int
  url: String
  width: Float
}

input CardPaginationQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: CardPageFilter
}

input CardPageFilter {
  id: ID
  ids: [ID]
  name: String
  externalId: [ID]
  videogameId: ID
}

type CardConnection {
  pageInfo: PageInfo
  nodes: [Card]
}

type PageInfo {
  total: Int
  totalPages: Int
  page: Int
  perPage: Int
  sortBy: String
  filter: JSON
}

"""Used to build the content sections of a profile"""
type ProfileContentRow {
  id: ID
  contentColumns: [ProfileContentColumn]
  images(type: String): [Image]
  profileId: ID
  profileType: String
  rowNum: Int
}

"""Used to build the content section columns of a profile"""
interface ProfileContentColumn {
  colNum: Int
  contentType: String
}

"""A user"""
type User {
  id: ID
  address: JSON @deprecated(reason: "Use User.location")

  """Admin only fields that the user can toggle publishing on"""
  adminFields: UserAdminFields

  """OAuth Clients"""
  authClients: [AuthClient]

  """Access tokens for our api"""
  authTokens(applicationType: AuthTokenApplicationType!): [AuthToken]

  """Authorizations to external services (i.e. Twitch, Twitter)"""
  authorizations(types: [SocialConnectionType]): [ProfileAuthorization]
  bio: String

  """Public facing user birthday that respects user publishing settings"""
  birthday: String

  """Is this user allowed to set a fee for online events?"""
  canUseOnlineFee: Boolean
  cookiesAccepted: Boolean
  createdAt: Timestamp
  deleteAfter: Timestamp

  """
  Uniquely identifying token for user. Same as the hashed part of the slug
  """
  discriminator: String
  dob: String
  email: String

  """Formatted selections for email settings"""
  emailSelections: JSON

  """Events this user has competed in"""
  events(query: UserEventsPaginationQuery): EventConnection
  genderPronoun: String

  """Flag for if a user has already claimed a vote against an event today"""
  hasClaimedDailyVotes(tournamentId: ID): Boolean

  """Is user linked to an external provider (MSA)"""
  hasExternal: Boolean
  hasPermission(permission: String, entityType: String, entityId: ID): Boolean
  images(type: String): [Image]

  """Is user following a given profile"""
  isFollowingProfile(profileType: String, profileId: ID): Boolean
  language: String

  """Leagues this user has competed in"""
  leagues(query: UserLeaguesPaginationQuery): LeagueConnection

  """Public location info for this user"""
  location: Address

  """Public facing user location that respects user publishing settings"""
  locationDisplay: String

  """Public facing user name that respects user publishing settings"""
  name: String
  nameFirst: String @deprecated(reason: "Use User.adminFields.nameFirst")
  nameLast: String @deprecated(reason: "Use User.adminFields.nameLast")

  """player for user"""
  player: Player
  playerId: Int @deprecated(reason: "Use User.player")

  """
  Get a specific ProfileAuthorization given a type (see AuthorizationType)
  """
  profileAuthorization(type: AuthorizationType!): ProfileAuthorization
  publishingSettings: UserPublishingSettings
  registrationState: Int

  """List of reports against the user"""
  reports: [UserPunishment]

  """Active requested email address change, if any"""
  requestedEmail: String
  requests(
    """Requests in this direction"""
    direction: RequestDirection!
    query: UserRequestQuery
  ): ProfileRequestConnection
  slug: String
  teams(query: TeamPaginationQuery): TeamConnection

  """Tournaments this user is organizing or competing in"""
  tournaments(query: UserTournamentsPaginationQuery): TournamentConnection

  """Url for public user profile"""
  url: String

  """User votes for this user"""
  votes: [Votes]
}

"""Raw values for fields that the user can toggle publishing on"""
type UserAdminFields {
  birthday: String
  location: Address
  nameFirst: String
  nameLast: String

  """
  Get a specific ProfileAuthorization given a type (see AuthorizationType)
  """
  profileAuthorization(type: AuthorizationType!): ProfileAuthorization
}

"""Represents the name of the third-party service (e.g Twitter) for OAuth"""
enum AuthorizationType {
  """"""
  TWITTER

  """"""
  TWITCH

  """"""
  STEAM

  """"""
  DISCORD

  """"""
  XBOX

  """"""
  EPIC

  """"""
  BATTLENET

  """"""
  RIOT

  """"""
  MIXER
}

"""An OAuth ProfileAuthorization object"""
type ProfileAuthorization {
  id: ID

  """The access token for this auth"""
  accessToken: String

  """Unix timestamp for when the token expires"""
  expiresAt: Timestamp

  """The id given by the external service"""
  externalId: String

  """
  The username given by the external service (including discriminator if discord)
  """
  externalUsername: String
  isValid: Boolean

  """Service-specific metadata"""
  metadata: JSON
  stream: Stream

  """
  The name of the external service providing this auth i.e. "twitch"
  """
  type: AuthorizationType
  url: String
}

"""A Stream object"""
type Stream {
  id: ID

  """The id given by the external stream service i.e. twitch channelId"""
  externalStreamId: String

  """Whether the stream is currently live. May be slightly delayed."""
  isOnline: Boolean

  """The name of the stream"""
  name: String

  """
  The name of the external service providing this auth i.e. "twitch"
  """
  type: StreamType
}

"""Represents the type of stream service"""
enum StreamType {
  """"""
  TWITCH

  """"""
  MIXER

  """"""
  YOUTUBE
}

"""An auth client"""
type AuthClient {
  id: ID
  appUrl: String
  clientSecret: String
  createdAt: Timestamp
  description: String
  name: String
  ownerId: Int
  redirect_uri: String
}

"""
Represents what type of application is generating the token e.g. personal or third party
"""
enum AuthTokenApplicationType {
  """"""
  PERSONAL

  """"""
  THIRD_PARTY
}

"""An auth token"""
type AuthToken {
  id: ID
  apiVersion: String
  clientId: Int
  createdAt: Timestamp
  description: String
  expiresAt: Timestamp
  roles: [Role]
  scopes: String
  type: Int
  user: User
}

"""A role"""
type Role {
  id: ID
  entityId: Int

  """Name of the entity associated with this role"""
  entityName: String
  entityType: String
  roleName: String

  """Status of if this role was accepted/rejected/pending/etc"""
  status: RequestStatus

  """User associated with this role"""
  user: User
}

"""Status of a request"""
enum RequestStatus {
  """"""
  PENDING

  """"""
  ACCEPTED

  """"""
  REJECTED

  """"""
  HIDDEN
}

"""
Represents the name of the third-party social service (e.g Twitter) for OAuth
"""
enum SocialConnectionType {
  """"""
  TWITTER

  """"""
  TWITCH

  """"""
  DISCORD

  """"""
  MIXER

  """"""
  XBOX
}

input UserEventsPaginationQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: UserEventsPaginationFilter
}

input UserEventsPaginationFilter {
  videogameId: [ID]
  eventType: Int
  minEntrantCount: Int
  maxEntrantCount: Int
  location: LocationFilterType
  search: PaginationSearchType
}

input LocationFilterType {
  countryCode: String
  state: String
  city: String
}

input PaginationSearchType {
  fieldsToSearch: [String]
  searchString: String
}

type EventConnection {
  pageInfo: PageInfo
  nodes: [Event]
}

"""An event in a tournament"""
type Event {
  id: ID

  """true if brackets are published for this event"""
  bracketsPublished: Boolean

  """Can entrants edit teams in this event"""
  canEditTeams: Boolean

  """How long before the event start will the check-in end (in seconds)"""
  checkInBuffer: Int

  """How long the event check-in will last (in seconds)"""
  checkInDuration: Int

  """Whether check-in is enabled for this event"""
  checkInEnabled: Boolean
  checkInGroupFirebasePath: String

  """Circuit event links for this event"""
  circuitEventLinks(
    """League id to filter event links on"""
    leagueId: ID
  ): [CircuitEventLink]

  """
  Rough categorization of event tier, denoting relative importance in the competitive scene
  """
  competitionTier: Int

  """When the event was created (unix timestamp)"""
  createdAt: Timestamp

  """Last date attendees are able to create teams for team events"""
  deckSubmissionDeadline: Timestamp

  """true if hasDecks and are published for this event"""
  decksPublished: Boolean

  """Maximum number of participants each Entrant can have"""
  entrantSizeMax: Int @deprecated(reason: "Migrate to teamRosterSize")

  """Minimum number of participants each Entrant can have"""
  entrantSizeMin: Int @deprecated(reason: "Migrate to teamRosterSize")

  """The entrants that belong to an event, paginated by filter criteria"""
  entrants(query: EventEntrantPageQuery): EntrantConnection

  """How much it costs to enter this event"""
  entryFee: Float

  """event check in groups linked to the event"""
  eventCheckInGroups: [EventCheckInGroup]

  """Number of event seeds that have an error"""
  eventSeedErrorCount: Int

  """Event seeds in the event"""
  eventSeeds(query: EventSeedPageQuery): EventSeedConnection
  firebasePath: String

  """When does the first round of the event start"""
  firstRoundTime: Timestamp

  """Whether the event has decks"""
  hasDecks: Boolean

  """Whether or not this event has a Race bracket."""
  hasRace: Boolean

  """Are player tasks enabled for this event"""
  hasTasks: Boolean
  images(type: String): [Image]

  """Whether or not the Event has been completed"""
  isCompleted: Boolean

  """Whether or not this is an FFA Event."""
  isFFA: Boolean

  """Whether the event is an online event or not"""
  isOnline: Boolean
  isRegistrationOpen: Boolean

  """Whether or not this event is a single bracket event."""
  isSingleBracket: Boolean

  """Indicates whether this event is a teams event."""
  isTeams: Boolean

  """Is this user registered for this event"""
  isUserRegistered(
    """
    User to get registration info for. Defaults to currently logged in user.
    """
    userId: ID
  ): Boolean
  league: League

  """Max points this event is worth for a given league"""
  leagueMaxPoints(leagueId: ID): Int @deprecated(reason: "Uses old LeagueBL::getMaxPointsByEvents function")

  """Request tier that this event is in for a given league"""
  leagueTier(leagueId: ID): EventTier @deprecated(reason: "Uses old LeagueBL::getTiersForEvents function")

  """List of all leagues that this event is attached to"""
  leagues: [League]

  """Relevant visible links for this event."""
  links: [ProfileNavFeature]

  """Markdown field for match rules/instructions"""
  matchRulesMarkdown: String

  """Title of event set by organizer"""
  name: String

  """The Networks on which the Videogame will be played"""
  networks: [Network]

  """The earliest upcoming phase"""
  nextUpcomingPhase: Phase

  """Gets the number of entrants in this event"""
  numEntrants: Int

  """The phases that belong to an event, paginated by filter criteria"""
  paginatedPhaseGroups(query: EventPhaseGroupPageQuery): PhaseGroupConnection

  """The phases that belong to an event, paginated by filter criteria"""
  paginatedPhases(query: EventPhasePageQuery): PhaseConnection

  """Paginated sets on this event"""
  paginatedSets(
    page: Int
    perPage: Int

    """How to sort these sets"""
    sortType: SetSortType

    """Supported filter options to filter down set results."""
    filters: SetFilters
  ): SetConnection

  """The phase groups that belong to an event."""
  phaseGroups: [PhaseGroup]

  """The phases that belong to an event."""
  phases(
    """Filter phases by state. If not specified will default to all phases"""
    state: ActivityState

    """Optionally only return results for this phase"""
    phaseId: ID
  ): [Phase]

  """The Platforms on which the Event's Videogame will be played"""
  platforms: [Platform]

  """TO settings for prizing"""
  prizingInfo: JSON

  """Shop products given out as prizes"""
  prizingProducts: [ShopProduct]
  publishing: JSON

  """When does registration closed for this Event?"""
  registrationDeadline: Timestamp

  """RegistrationOptions for this event."""
  registrationOptions(
    """
    Filter RegistrationOptions by fieldType. Omitting this argument will return all matched RegistrationOptions.
    """
    optionType: String
  ): [RegistrationOption]
  requests(
    """Requests in this direction"""
    direction: RequestDirection!
    query: EventRequestQuery
  ): ProfileRequestConnection

  """
  Whether or not Teams can register without having all required slots filled
  """
  requireFullTeam: Boolean

  """
  A list of possible restrictions that can be assigned to entities in this event
  """
  restrictions: [EntityRestriction]

  """Markdown field for event rules/instructions"""
  rulesMarkdown: String

  """The ruleset for this event"""
  ruleset: Ruleset

  """Id of the event ruleset"""
  rulesetId: Int

  """Settings pulled from the event ruleset, if one exists"""
  rulesetSettings: JSON @deprecated(reason: "Use ruleset")

  """true if seeding is published for this event"""
  seedingPublished: Boolean
  seeds(query: SeedPaginationQuery!): SeedConnection

  """Returns whether or not self-reporting is enabled for this event"""
  selfReportingEnabled: Boolean

  """Paginated sets for this Event"""
  sets(
    page: Int
    perPage: Int

    """How to sort these sets"""
    sortType: SetSortType

    """Supported filter options to filter down set results."""
    filters: SetFilters
  ): SetConnection
  slug: String

  """Paginated list of standings"""
  standings(query: StandingPaginationQuery!): StandingConnection

  """When does this event start?"""
  startAt: Timestamp

  """The state of the Event."""
  state: ActivityState

  """Paginated stations on this event"""
  stations(query: StationFilter): StationsConnection

  """
  If applicable, what subleagues this event is part of. Optionally filter on parent league
  """
  subleagues(leagueId: ID): [Tournament]

  """Last date attendees are able to create teams for team events"""
  teamManagementDeadline: Timestamp

  """
  If this is a teams event, returns whether or not teams can set custom names
  """
  teamNameAllowed: Boolean

  """Team roster size requirements"""
  teamRosterSize: TeamRosterSize

  """
  Get a list of the top X entrants for this event. This supports batches of events
  """
  topEntrants(limit: Int!): [Entrant]

  """
  Get a list of the top X participants for this event. This supports batches of events
  """
  topParticipants(limit: Int!): [Participant]

  """
  Get a list of the top X standings for this event. This supports batches of events
  """
  topStandings(limit: Int!): [Standing]
  tournament: Tournament

  """
  The type of the event, whether an entrant will have one participant or multiple
  """
  type: Int

  """When the event was last modified (unix timestamp)"""
  updatedAt: Timestamp

  """URL for the Event. Optionally, build URL for resource under the Event"""
  url(
    """Event tab to build URL for"""
    tab: String

    """
    Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
    """
    relative: Boolean = true
  ): String

  """Whether the event uses the new EventSeeds for seeding"""
  useEventSeeds: Boolean

  """The entrant (if applicable) for a given user in this event"""
  userEntrant(
    """User to get entrant for. Defaults to currently logged in user."""
    userId: ID
  ): Entrant

  """
  Returns the logged in User's next match start time. This is the end-all-be-all source of truth. I promise.
  """
  userNextMatchTime: Timestamp

  """Return list of Sets that the current user is participating in"""
  userSets(
    """User to get sets for. Defaults to currently logged in user."""
    userId: ID
    sortType: SetSortType = MAGIC
    limit: Int = null
  ): [Set]

  """The current user's tasks for this event"""
  userTasks(allowFallbackTasks: Boolean = false, abortIfNotActive: Boolean = false, activeOnly: Boolean = true, excludeSystemIds: [ID] = null, limit: Int = null, shouldAggregate: Boolean = true, ctaMode: TaskCTAMode = STANDARD, viewFormat: TaskViewFormat = FULL_TASK): [Task]
  videogame: Videogame

  """Id of the videogame associated with this event"""
  videogameId: Int @deprecated(reason: "Use videogame")

  """The waves being used by the event"""
  waves(
    """Waves filtered by phaseId, returns all if not set."""
    phaseId: ID
  ): [Wave]

  """The entrant that won this event"""
  winnerEntrant: Entrant
}

"""Links an event to a circuit, and holds data about the relation"""
type CircuitEventLink {
  id: ID

  """Point mapping group"""
  pointMappingGroup: PointMappingGroup

  """Circuit Tier for this Event"""
  tier: EventTier
  unpublished: Boolean
}

"""A group of point mappings for a particular standing group"""
type PointMappingGroup {
  id: ID
  name: String

  """Number of events linked to this group"""
  numEvents: Int

  """Point mappings for this group"""
  pointMappings: [PointMapping]
}

"""Defines the mapping of a field, or stat, to Standing Points"""
type PointMapping {
  id: ID
  config: JSON
  field: String

  """Range DSL string of point mapping's config"""
  rangeDSL: String
  type: String
}

"""Used for league application tiers"""
type EventTier {
  id: ID

  """Additional criteria of tier."""
  additionalCriteria: Criteria
  description: String
  endAt: Timestamp

  """Name of this tier"""
  name: String

  """Point mapping group"""
  pointMappingGroup: PointMappingGroup
  startAt: Timestamp
}

"""Fields used in a Request Tier's additionalCriteria field"""
type Criteria {
  """End date for tier"""
  endAt: Timestamp

  """Max entrant count of the tier"""
  entrantCountMax: Int

  """Min entrant count of the tier"""
  entrantCountMin: Int

  """Tier location filter on Latitude, Longitude, and Radius"""
  location: JSON

  """Tier location filter on City"""
  locationCity: String

  """Tier location filter on Country"""
  locationCountry: String

  """Tier location filter on State"""
  locationState: String

  """Filter on online, offline, or neither"""
  online: Boolean

  """IDs of Platform"""
  platformIds: [ID]

  """Start date for tier"""
  startAt: Timestamp

  """Tier filter on event type"""
  type: [Int]

  """List of VideoGame ids"""
  videogameId: [ID]
}

input EventEntrantPageQuery {
  page: Int
  perPage: Int
  sortBy: String
  filter: EventEntrantPageQueryFilter
}

input EventEntrantPageQueryFilter {
  name: String
}

type EntrantConnection {
  pageInfo: PageInfo
  nodes: [Entrant]
}

"""An entrant in an event"""
type Entrant {
  id: ID

  """An entrant's first round seed associated with their event check-in"""
  checkInSeed: Seed
  decks: [Deck]
  event: Event
  eventId: Int @deprecated(reason: "Use event instead")

  """
  expands entrant name to [entrant.participant.prefix,
  entrant.participant.gamerTag] for singles and [null, entrant.name] for
  """
  expandedName: EntrantExpandedName
  hasIncompleteDecks: Boolean

  """Entrant's seed number in the first phase of the event."""
  initialSeedNum: Int
  isDisqualified: Boolean
  lastMatches: [Set]
  lostTo: JSON

  """Gamertags of all members of entrant (only relevant for teams)"""
  memberNames: [String]

  """
  The entrant name as it appears in bracket: gamerTag of the participant or team name
  """
  name: String

  """Computed display name for Participant(s) from Network IDs"""
  networkIdDisplayName: String

  """Paginated sets for this entrant"""
  paginatedSets(
    page: Int
    perPage: Int

    """How to sort these sets"""
    sortType: SetSortType

    """Supported filter options to filter down set results."""
    filters: SetFilters
  ): SetConnection
  participants: [Participant]

  """The phase groups this entrant is in"""
  phaseGroups: [PhaseGroup]

  """Player tied to the entrant. This does not work for teams."""
  players: [Player]

  """The record of the entrant in the event"""
  record: JSON
  seed(phaseId: ID, phaseGroupId: ID): Seed
  seeds: [Seed]
  setIdentifier(phaseGroupId: ID, round: Int): String
  skill: Int
  slug: String

  """
  Standing for this entrant given an event. All entrants queried must be in the same event (for now).
  """
  standing: Standing
  stream: Streams @deprecated(reason: "DEPRECATED. Use streams instead, which supports multiple stream types and teams.")
  streams: [Streams]

  """Team linked to this entrant, if one exists"""
  team: Team

  """Url for public entrant page"""
  url: String
}

"""A seed for an entrant"""
type Seed {
  id: ID

  """
  The state of the seed for event check-in. Conforms to CheckInState enum.
  """
  checkInState: SeedCheckInState

  """Map of Participant ID to checked in boolean"""
  checkedInParticipants: JSON
  entrant: Entrant
  entrantId: Int @deprecated(reason: "Use Entrant")

  """Set count and game count by this entrant"""
  gameAndSetCounts(phaseGroupId: ID!, eventId: ID): JSON
  groupSeedNum: Int
  isBye: Boolean

  """
  The entrant(s) that won the match that determined this entrant's elimination.
  """
  lostTo(phaseGroupId: ID!): JSON
  phase: Phase
  phaseGroup: PhaseGroup
  placeholderName: String
  placement: Int

  """The player(s) associated with this seed's entrant"""
  players: [Player]

  """Destination progression information for this seed"""
  progression: JSON
  progressionSeedId: Int

  """Source progression information"""
  progressionSource: Progression

  """Ladder entrant's current and highest stable rank recorded"""
  ranks(phaseGroupId: ID!): JSON
  seedNum: Int

  """
  Entrant's win/loss record for this standing. Scores do not include byes.
  """
  setRecordWithoutByes(phaseGroupId: ID!): JSON

  """Gets sets in this phaseGroup for this seed."""
  sets(
    """Filter which sets are returned by state."""
    stateFilter: SetStateFilter = {type: "exclude", states: []}
  ): [Set]
  standings(
    """
    The container of the standing groups to get standings for. If null, will return all standings.
    """
    containerType: String
  ): [Standing]

  """Tiebreak information for this seed"""
  tiebreakInfo(phaseGroupId: ID!): JSON
}

"""Action to take when check-in ends"""
enum SeedCheckInState {
  """Will not have to checkin"""
  NONE

  """Will have to checkin"""
  REQUIRED

  """Checked in but the deadline has not been reached yet"""
  CHECKED_IN

  """Checked in and the deadline has been reached"""
  MADE_IT

  """Not checked in and the deadline has passed"""
  MISSED_IT

  """"""
  IGNORE
}

"""A phase in an event"""
type Phase {
  id: ID

  """Bracket-type specific Phase configuration"""
  bracketConfig: BracketConfig

  """The bracket type of this phase."""
  bracketType: BracketType

  """true if brackets are published for this phase"""
  bracketsPublished: Boolean

  """Whether the phase is eligible for check-in"""
  canEnableCheckIn: Boolean

  """Whether the phase has check-in enabled"""
  checkInEnabled: Boolean
  destPhaseLinks: [PhaseLink]

  """A list of destination phases from this current phase"""
  destPhases: [Phase]

  """The Event that this phase belongs to"""
  event: Event

  """Number of phase groups in this phase"""
  groupCount: Int
  groupTypeId: Int @deprecated(reason: "Use bracketType instead. Leaving this in for backwards compatibility.")

  """Whether or not a phase's group type is supported by event check-in."""
  groupTypeSupportedByEventCheckIn: Boolean

  """Whether or not a phase has progressions leading into it."""
  hasProgressionsIn: Boolean

  """Whether the phase is the default phase or not."""
  isDefault: Boolean

  """Is the phase an exhibition or not."""
  isExhibition: Boolean

  """Bracket-type specific Phase configuration for Matches"""
  matchConfig: MatchConfig

  """Name of phase e.g. Round 1 Pools"""
  name: String

  """The number of seeds this phase contains."""
  numSeeds: Int

  """OLD, NEED TO REMOVE. unpaginated phase groups under this phase"""
  oldPhaseGroups: [PhaseGroup]
  paginatedSeeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection @deprecated(reason: "Please use 'seeds' instead")

  """Percentage of matches completed for this phase"""
  percentComplete: Int

  """Phase groups under this phase, paginated"""
  phaseGroups(query: PhaseGroupPageQuery): PhaseGroupConnection

  """The relative order of this phase within an event"""
  phaseOrder: Int

  """Information about the progressions into this phase"""
  progressingInData: [ProgressionData]

  """Information about the progressions into this phase"""
  progressionData: [ProgressionData]

  """Information about the progressions out of this phase"""
  progressions: [Progression]

  """true if seeding is published for this phase"""
  seedingPublished: Boolean

  """Paginated seeds for this phase"""
  seeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection

  """Paginated sets for this Phase"""
  sets(
    page: Int
    perPage: Int

    """How to sort these sets"""
    sortType: SetSortType

    """Supported filter options to filter down set results."""
    filters: SetFilters
  ): SetConnection

  """Default standings configuration for this Phase"""
  standingsConfig: StandingsConfig

  """
  Start time of phase computed based on event start time, waves, and phase groups
  """
  startAt: Timestamp

  """State of the phase"""
  state: ActivityState

  """Default stats configuration for this Phase"""
  statsConfig: StatsConfig

  """The current user's tasks for this phase"""
  userTasks: [Task]
  waves: [Wave]
}

"""Bracket-specific configuration"""
interface BracketConfig {
  id: ID
  bracketType: BracketType
}

"""The type of Bracket format that a Phase is configured with."""
enum BracketType {
  """"""
  SINGLE_ELIMINATION

  """"""
  DOUBLE_ELIMINATION

  """"""
  ROUND_ROBIN

  """"""
  SWISS

  """"""
  EXHIBITION

  """"""
  CUSTOM_SCHEDULE

  """"""
  MATCHMAKING

  """"""
  ELIMINATION_ROUNDS

  """"""
  RACE

  """"""
  CIRCUIT
}

"""A link which defines how players enter and progress from phases"""
type PhaseLink {
  id: ID

  """Seed number that the seed phase link ends at (inclusive)"""
  endSeed: Int

  """The mode for a seed phase link"""
  seedMode: String

  """Seed number that the seed phase link starts at (inclusive)"""
  startSeed: Int

  """The type of this phase link"""
  type: PhaseLinkType
}

"""The type of the phase link. Different types have different behaviors"""
enum PhaseLinkType {
  """Phase link for phase to phase progressions based on placement"""
  PLACEMENT

  """Used for amateur brackets to progress remainder players"""
  REMAINDER

  """Directly added entrants"""
  DIRECT

  """Event seed configuration definitions"""
  SEED
}

"""Match-level configuration"""
interface MatchConfig {
  id: ID
  bracketType: BracketType
}

"""A group within a phase"""
type PhaseGroup {
  """The bracket type of this group's phase."""
  bracketType: BracketType
  id: ID

  """URL for this phase groups's bracket."""
  bracketUrl: String
  checkInFinalizeAction: String
  checkInState: String

  """The sets of current round of a phase group"""
  currentRoundSets: [Set]

  """Unique identifier for this group within the context of its phase"""
  displayIdentifier: String

  """Event check in groups that the phase group is linked to"""
  eventCheckInGroup: EventCheckInGroup
  firebasePath: String

  """
  For the given phase group, this is the start time of the first round that occurs in the group.
  """
  firstRoundTime: Timestamp
  groupTypeId: Int

  """
  Matchmaking settings for this Phase Group. Should only be used in queries for
  Phase Groups that are known to be of the Matchmaking bracket type.
  """
  matchmakingSettings: JSON
  numRounds: Int

  """The number of seeds for a phase group."""
  numSeeds(checkInState: Int): Int
  oldSets(
    """Limit to Sets in the current round"""
    currentRoundOnly: Boolean = false
  ): [Set]
  paginatedSeeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection @deprecated(reason: "Please use 'seeds', which is now paginated")

  """Paginated sets on this phaseGroup"""
  paginatedSets(
    page: Int
    perPage: Int

    """How to sort these sets"""
    sortType: SetSortType

    """Supported filter options to filter down set results."""
    filters: SetFilters
  ): SetConnection @deprecated(reason: "Please use 'sets', which is now paginated")

  """Percentage of matches completed for this phase group"""
  percentComplete: Int

  """The phase associated with this phase group"""
  phase: Phase
  phaseId: Int @deprecated(reason: "Use phase")

  """The progressions out of this phase group"""
  progressionsOut: [Progression]
  raceConfig: JSON
  roundDisplayNames: JSON @deprecated(reason: "This is the wrong API for getting round titles. We need to put more work into the phaseGroup.rounds resolver to make it useful.")
  rounds: [Round]
  seedMap: JSON

  """Paginated seeds for this phase group"""
  seeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection

  """Paginated sets on this phaseGroup"""
  sets(
    page: Int
    perPage: Int

    """How to sort these sets"""
    sortType: SetSortType

    """Supported filter options to filter down set results."""
    filters: SetFilters
  ): SetConnection
  standingGroup: StandingGroup

  """Paginated list of standings"""
  standings(query: StandingGroupStandingPageFilter): StandingConnection

  """
  Unix time the group is scheduled to start. This info could also be on the wave instead.
  """
  startAt: Timestamp
  state: Int

  """Paginated stations on this phaseGroup"""
  stations(query: StationFilter): StationsConnection
  tiebreakOrder: JSON
  unpaginatedSeeds: [Seed]

  """
  URL for the phase group. Optionally, build URL for resource under the phase group
  """
  url(
    """Phase group (brackets) tab to build URL for"""
    tab: String

    """
    Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
    """
    relative: Boolean = true
  ): String

  """
  Gets seeds in this phaseGroup for a particular user. Normally this will only
  be 0 or 1 seed. There might be weird cases where someone has more seeds
  """
  userSeeds(
    """User ID to get sets for. If null, will default to current user."""
    userId: ID
  ): [Seed]

  """The current user's tasks for this phase group"""
  userTasks: [Task]
  wave: Wave
  waveId: Int @deprecated(reason: "Use wave")
}

"""A set"""
type Set {
  id: ID

  """A list of games that could be reported via API for this set"""
  apiGames: JSON

  """The possible inputs to the external API for fetching results"""
  apiReportingInputOptions: JSON
  bracketLink: String
  bracketName: String

  """Whether or not this set supports API reporting"""
  canApiReport: Boolean
  characters(mainEntrantId: ID): JSON

  """The time this set was marked as completed"""
  completedAt: Timestamp

  """The time this set was created"""
  createdAt: Timestamp
  currentUserSeedId: ID
  defaultStandingGroup: StandingGroup
  displayScore(mainEntrantId: ID): String
  entrant1Id: Int @deprecated(reason: "Deprecated field. Use slots instead.")
  entrant1Present: Boolean @deprecated(reason: "Do not use. Deprecated field.")
  entrant1Score: Int @deprecated(reason: "Should eventually exist on Standing, deprecate when it does")

  """The source of the first entrant in this set"""
  entrant1Source: SetEntrantSource
  entrant2Id: Int @deprecated(reason: "Deprecated field. Use slots instead.")
  entrant2Present: Boolean @deprecated(reason: "Do not use. Deprecated field.")
  entrant2Score: Int @deprecated(reason: "Should eventually exist on Standing, deprecate when it does")

  """The source of the second entrant in this set"""
  entrant2Source: SetEntrantSource

  """Retrieves a single slot in a set, given an entrantId"""
  entrantSlot(entrantId: ID): SetSlot

  """Event that this set belongs to."""
  event: Event

  """ID of the event this set belongs to"""
  eventId: Int @deprecated(reason: "Use event")

  """The number of set slots that have been occupied by an Entrant"""
  filledSlots: Int

  """Full round text of this set."""
  fullRoundText: String
  game(orderNum: Int!): Game
  games: [Game]

  """Whether this set contains a placeholder entrant"""
  hasPlaceholder: Boolean

  """
  The letters that describe a unique identifier within the pool. Eg. F, AT
  """
  identifier: String
  images(type: String): [Image]

  """Whether or not the authenticated user is participating in this Set."""
  isCurrentUserParticipating: Boolean

  """
  True if this set is allowed to be edited. If this is false, then there are downstream sets that have already been reported
  """
  isEditable: Boolean

  """
  Indicates whether this set is a preview set. Preview sets should support fewer
  actions because they do not exist in the database.
  """
  isPreview: Boolean

  """
  Indicates whether a set is reportable. This becomes true when all the slots are populated with a seed.
  """
  isReportable: Boolean
  isWinner(mainEntrantId: ID!): Boolean
  lPlacement: Int

  """
  The progression seed that the loser of this set will be placed into (if applicable)
  """
  loserProgressionSeed: Seed

  """
  The current user's tasks for this set. Uses the deprecated task system.
  """
  oldSetTasks: [OldSetTask] @deprecated(reason: "Being replaced with userTasks eventually.")
  opponentName(mainEntrantId: ID!): String

  """Paginated list of slots in a set"""
  paginatedSlots(query: SlotPageFilter, includeByes: Boolean = false): SetSlotConnection

  """Phase group that this Set belongs to."""
  phaseGroup: PhaseGroup
  phaseGroupId: Int @deprecated(reason: "Use phaseGroup")

  """
  Retrieves a single slot in a set, given a playerId. Defaults to current player
  """
  playerSlot(playerId: ID): SetSlot

  """Tasks for the player, on the set"""
  playerTasks: [ProfileTask]
  pointCalcConfig: [PointSource]

  """The sets that are affected from resetting this set"""
  resetAffectedData: ResetAffectedData
  resultText(mainEntrantId: ID!): String

  """The round number of the set. Negative numbers are losers bracket"""
  round: Int

  """
  Indicates whether the set is in best of or total games mode. This instructs
  which field is used to figure out how many games are in this set.
  """
  setGamesType: Int
  setLink: String

  """
  A possible spot in a set. Use this to get all entrants in a set. Use this for all bracket types (FFA, elimination, etc)
  """
  slots(includeByes: Boolean = false): [SetSlot]

  """
  The start time of the Set. If there is no startAt time on the Set, will pull it from phaseGroup rounds configuration.
  """
  startAt: Timestamp
  startedAt: Timestamp
  state: Int

  """Tournament event station for a set"""
  station: Stations
  stationId: Int @deprecated(reason: "Use station")

  """Station number of this set."""
  stationNumber: Int

  """The stats as computed by the UIMapping for this set."""
  stats(view: String = "setFinalization"): JSON

  """Tournament event stream for a set"""
  stream: Streams
  streamId: Int @deprecated(reason: "Use stream")

  """
  If setGamesType is in total games mode, this defined the number of games in the set.
  """
  totalGames: Int

  """The total possible number of slots available for Entrants"""
  totalSlots: Int

  """Tournament that this set belongs to."""
  tournament: Tournament
  uiMapping(view: String = "setFinalization"): UIMapping

  """The time this set was last updated"""
  updatedAt: Timestamp

  """
  Generally used in conjunction with firebase to see if set data should be updated
  """
  updatedAtMicro: Float

  """The current user's tasks for this set"""
  userTasks(allowFallbackTasks: Boolean = false, ctaMode: TaskCTAMode = STANDARD, viewFormat: TaskViewFormat = FULL_TASK, limit: Int = null, activeOnly: Boolean = true): [Task]

  """Url of a VOD for this set"""
  vodUrl: String
  wPlacement: Int
  winnerId: Int

  """
  The progression seed that the winner of this set will be placed into (if applicable)
  """
  winnerProgressionSeed: Seed
}

"""
A standing group is a container for standings. The type field describes how the standings get calculated.
"""
type StandingGroup {
  id: ID
  config: JSON

  """Filters that can be applied to the paginated standings"""
  customFilters: [StandingGroupCustomFilterDefinition]
  isDefault: Boolean
  name: String

  """Paginated standings for this standing group"""
  paginatedStandings(query: StandingGroupStandingsPaginationQuery): StandingConnection

  """Point structures for a tier"""
  pointStructures: JSON
  standings: [Standing]

  """Standing for a given user"""
  userStanding(userId: ID): Standing
}

"""A filter that can be applied to the paginated standings"""
type StandingGroupCustomFilterDefinition {
  key: String
  displayName: String
  values: [StandingGroupCustomFilterValue]
}

"""A value of a filter that can be applied to the paginated standings"""
type StandingGroupCustomFilterValue {
  value: String
  displayName: String
}

input StandingGroupStandingsPaginationQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: StandingGroupStandingsPageFilter
}

input StandingGroupStandingsPageFilter {
  search: PaginationSearchType
  customFilters: [StandingGroupStandingsCustomFilter]
}

input StandingGroupStandingsCustomFilter {
  key: String
  value: String
}

type StandingConnection {
  pageInfo: PageInfo
  nodes: [Standing]
  filterLocalPlacementStart: Int
}

"""A standing indicates the placement of something within a container."""
type Standing {
  id: ID
  additionalDisplayColumns: [AdditionalColumn]

  """
  The containing entity that contextualizes this standing. Event standings, for
  example, represent an entrant's standing in the entire event vs. Set standings
  which is an entrant's standing in only a single set within an event.
  """
  container: StandingContainer
  entityId: Int @deprecated(reason: "We should add an entity resolver")
  entityType: String @deprecated(reason: "We should add an entity resolver")

  """
  If the entity this standing is assigned to can be resolved into an entrant, this will provide the entrant.
  """
  entrant: Entrant

  """The event this standing belongs to (if applicable)"""
  event: Event
  eventStandingPoints(entrantId: ID): StandingPoints
  isFinal: Boolean

  """
  The last two matches played by the entrant for this standing (if applicable)
  """
  lastMatches: JSON

  """
  Metadata that goes along with this standing. Can take on different forms based on standing group type and settings.
  """
  metadata: JSON
  numUniqueEvents: Int

  """
  What the standing is outOf, for example 1st out of 100. This is the total
  number of standings in the containing standing group.
  """
  outOf: Int
  placement: Int

  """The player(s) tied to this standing's entity"""
  player: Player
  points: [StandingPoints]
  pointsFromGame(setId: ID!, gameIndex: Int!): [StandingPoints]

  """The event level prizing this standing receives"""
  prizing: [EventPrizing]

  """The event level prize/winnings that this standing receives"""
  prizingAmount: Float @deprecated(reason: "Deprecated in favor of `prizing` field")

  """Entrant's win/loss record for this standing"""
  setRecordWithoutByes: JSON
  standing: Int @deprecated(reason: "The \"placement\" field is identical and will eventually replace \"standing\"")
  stats: StandingStats

  """The team tied to this standing's entity"""
  team: Team
  totalPoints: Float
}

"""Describes a label and value to display along with a standing."""
type AdditionalColumn {
  """The name of the label. Will show up as a column header."""
  label: String!

  """The value to display."""
  value: String
}

"""The containing entity that this standing is for"""
union StandingContainer = Tournament | Event | PhaseGroup | Set

"""A tournament"""
type Tournament {
  """Is there action required for this tournament to operate."""
  actionRequired: Boolean
  id: ID
  addrState: String

  """Build Tournament admin URL"""
  adminUrl(
    """Tournament admin tab to add to URL"""
    tab: String

    """
    Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
    """
    relative: Boolean = true
  ): String

  """Admin-only view of admins for this tournament"""
  admins(
    """Which roles to show"""
    roles: [String]
  ): [User]
  approved: Boolean

  """Attendee requirements for this tournament"""
  attendeeFieldConfig: JSON
  city: String
  contactEmail: String @deprecated(reason: "Use primaryContact fields")
  contactPhone: String @deprecated(reason: "Use primaryContact fields")
  contactTwitter: String @deprecated(reason: "Use primaryContact fields")
  countryCode: String

  """When the tournament was created (unix timestamp)"""
  createdAt: Timestamp
  currency: String
  customMarkdown: JSON @deprecated(reason: "No longer used")
  defaultTab: String
  details: String @deprecated(reason: "No longer used")
  emailDirections: String
  emailInstructions: String
  emailNote: String

  """When the tournament ends"""
  endAt: Timestamp

  """Get the groupings of events in this tournament."""
  eventGroups: [EventGroup]

  """When does event registration close"""
  eventRegistrationClosesAt: Timestamp

  """
  Get all event level teams in this tournament for a given global team or player
  """
  eventTeams(globalTeamId: ID, playerId: ID): [EventTeam]
  events(limit: Int, filter: EventFilter): [Event]
  fullAddress: String
  gamesList: [Videogame]
  generatedTabs: JSON
  gettingThere: String @deprecated(reason: "No longer used")

  """True if tournament has at least one offline event"""
  hasOfflineEvents: Boolean
  hasOnlineEvents: Boolean
  hashtag: String

  """Whether or not to hide the admins"""
  hideAdmins: Boolean
  images(type: String): [Image]
  includeQRCheckIn: Boolean
  includeQRCode: Boolean
  isCentralized: Boolean

  """True if tournament has at least one online event"""
  isOnline: Boolean

  """Is tournament registration open"""
  isRegistrationOpen: Boolean
  lat: Float
  links: TournamentLinks
  lng: Float
  locationDisplayName: String
  mapsPlaceId: String
  merchantConnectionId: Int

  """The tournament name"""
  name: String

  """Get nomination event linked to this tournament"""
  nominationEvent: NominationEvent

  """Whether to send admin emails when a new person registers"""
  notifyAdmins: Boolean

  """Number of attendees including spectators, if public"""
  numAttendees: Int
  onsitePaymentMode: String

  """The user who created the tournament"""
  owner: User
  ownerId: Int @deprecated(reason: "We should add an owner resolver if we need this")

  """Paginated, queryable list of participants"""
  participants(query: ParticipantPaginationQuery!, isAdmin: Boolean): ParticipantConnection
  paypalMode: String
  permissionType: String
  postalCode: String
  primaryContact: String
  primaryContactType: String
  prizes: String @deprecated(reason: "No longer used")
  profileLinks(
    """Hub id to filter profile links on"""
    hubId: ID
  ): [ProfileLink]

  """Publishing settings for this tournament"""
  publishing: JSON
  qrCodeRedirect: String
  qrCodeRedirectType: String

  """The region of the tournament"""
  region: String @deprecated(reason: "No longer used")
  regionDisplayName: String

  """When does registration for the tournament end"""
  registrationClosesAt: Timestamp

  """RegistrationOptions for this Tournament"""
  registrationOptions(
    """
    Filter RegistrationOptions by fieldType. Omit this argument to return all RegistrationOptions.
    """
    optionType: String
  ): [RegistrationOption]

  """
  The period of time before the start date to send a reminder email to registrants
  """
  reminderInterval: Int
  requests(
    """Requests in this direction"""
    direction: RequestDirection!
    query: TournamentRequestQuery
  ): ProfileRequestConnection

  """Total user transaction revenue for this tournament"""
  revenue: Float
  rules: String

  """Returns a paginated list of Sets"""
  sets(
    page: Int
    perPage: Int

    """How to sort these sets"""
    sortType: SetSortType

    """Supported filter options to filter down set results."""
    filters: SetFilters
  ): SetConnection

  """Shop products attached to this tournament"""
  shopProducts(
    """Supported shop product filters"""
    filter: ShopProductFilter
  ): [ShopProduct]

  """The short slug used to form the url"""
  shortSlug: String

  """The slug used to form the url"""
  slug: String

  """When the tournament Starts"""
  startAt: Timestamp

  """
  State of the tournament, can be ActivityState::CREATED, ActivityState::ACTIVE, or ActivityState::COMPLETED
  """
  state: Int
  stations(page: Int, perPage: Int): StationsConnection
  streamQueue: [StreamQueue]
  streams: [Streams]
  stripeMode: String
  stripeUserId: String

  """When is the team creation deadline"""
  teamCreationClosesAt: Timestamp

  """Paginated, queryable list of teams"""
  teams(query: TeamPaginationQuery!): TeamConnection

  """The timezone of the tournament"""
  timezone: String

  """The type of tournament from TournamentType"""
  tournamentType: Int

  """When the tournament was last modified (unix timestamp)"""
  updatedAt: Timestamp

  """Build Tournament URL"""
  url(
    """Tournament tab to add to URL"""
    tab: String

    """
    Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
    """
    relative: Boolean = true
  ): String

  """
  Returns true if the supplied userId is an admin for the Tournament. Defaults
  to the currently logged in user if not provided.
  """
  userIsAdmin(userId: ID): Boolean

  """Get a given user's participant for this tournament"""
  userParticipant(
    """User ID to get participant for. If null, defaults to the current user."""
    userId: ID = null
  ): Participant

  """The current user's tasks for this tournament"""
  userTasks(activeOnly: Boolean = true, limit: Int = null): [Task]
  venueAddress: String
  venueName: String

  """List of all waves in this tournament"""
  waves: [Wave]
}

"""
A grouping of events within a tournament. Can be used for different registration limits or for display purposes.
"""
type EventGroup {
  id: ID
  eventIds: [ID]
  name: String
  orderNum: Int
  regLimit: Int
  tournamentId: ID
}

"""An event-level Team, in the context of some competition"""
type EventTeam implements Team {
  id: ID
  acceptedMembers: [TeamMember] @deprecated(reason: "Use the new members resolver with just accepted status")
  adminUrl(tab: String): String
  allowedActions: [ActionSummary]
  bio: String

  """Does this team have a complete set of accepted members"""
  complete: Boolean

  """
  Uniquely identifying token for team. Same as the hashed part of the slug
  """
  discriminator: String
  entrant: Entrant @deprecated(reason: "Use the entrant field off the EventTeam type")
  entrantId: Int @deprecated(reason: "Use entrant on EventTeam")
  event: Event @deprecated(reason: "Use the event field off the EventTeam type")
  eventId: Int @deprecated(reason: "Use event on EventTeam")
  globalTeam: GlobalTeam
  images(type: String): [Image]

  """
  Url that contains the inviteCode assigned to the team. This is the link team admins can share with new members.
  """
  inviteLink: String
  isCurrentUserAdmin: Boolean

  """Are join requests allowed for the team?"""
  joinRequestsAllowed: Boolean
  league: League

  """
  For a centralized league team, get all event-level teams that still have team management open
  """
  leagueManagedEventTeams: [EventTeam]
  members(status: [TeamMemberStatus]): [TeamMember]
  name: String

  """
  Given an invite code, provide a user specific invite link. This is dependent on the user's registration status
  """
  registrationInviteLink(
    """Invite code for the event team"""
    inviteCode: String!

    """User ID to get invite link for. If null, defaults to the current user."""
    userId: ID = null
  ): String
  restrictions: [EntityRestriction]
  slug: String
  teamRosterSize: TeamRosterSize
  type: Int
  url(tab: String): String
  userMember(
    """User ID to get member for. If null, defaults to the current user."""
    userId: ID = null
  ): TeamMember
  verified: Boolean
  videogame: Videogame
}

"""A team, either at the global level or within the context of an event"""
interface Team {
  id: ID
  acceptedMembers: [TeamMember] @deprecated(reason: "Use the new members resolver with just accepted status")
  adminUrl(tab: String): String
  bio: String

  """Does this team have a complete set of accepted members"""
  complete: Boolean

  """
  Uniquely identifying token for team. Same as the hashed part of the slug
  """
  discriminator: String
  entrant: Entrant @deprecated(reason: "Use the entrant field off the EventTeam type")
  entrantId: Int @deprecated(reason: "Use entrant on EventTeam")
  event: Event @deprecated(reason: "Use the event field off the EventTeam type")
  eventId: Int @deprecated(reason: "Use event on EventTeam")
  images(type: String): [Image]

  """
  Url that contains the inviteCode assigned to the team. This is the link team admins can share with new members.
  """
  inviteLink: String
  isCurrentUserAdmin: Boolean

  """Are join requests allowed for the team?"""
  joinRequestsAllowed: Boolean
  members(status: [TeamMemberStatus]): [TeamMember]
  name: String
  slug: String
  type: Int
  url(tab: String): String
  userMember(
    """User ID to get member for. If null, defaults to the current user."""
    userId: ID = null
  ): TeamMember
  verified: Boolean
  videogame: Videogame
}

"""A member of a team"""
type TeamMember {
  id: ID
  adminRole: Role
  createdAt: Timestamp
  inviteEmail: String
  isAlternate: Boolean
  isCaptain: Boolean
  isCoach: Boolean
  isStandIn: Boolean

  """The type of the team member"""
  memberType: TeamMemberType
  name: String
  participant: Participant

  """The participantId of the team member"""
  participantId: Int
  player: Player

  """The status of the team member"""
  status: TeamMemberStatus
  teamId: ID
}

"""Membership type of a team member"""
enum TeamMemberType {
  """"""
  PLAYER

  """"""
  STAFF
}

"""A participant of a tournament; either a spectator or competitor"""
type Participant {
  id: ID

  """How this participant was added"""
  addedByInfo: ParticipantAddedByInfo

  """Admin only field - actions performed by admins"""
  adminActions: [AdminActions]

  """Admin only field - notes written by admins"""
  adminNotes: [Note]

  """How much money this participant owes"""
  balance: Float

  """If this participant was checked-in by admin"""
  checkedIn: Boolean

  """The time this participant was checked-in by admin"""
  checkedInAt: Timestamp

  """If this participant is claimed or not"""
  claimed: Boolean

  """Info for connected accounts to external services."""
  connectedAccounts: JSON

  """
  Contact Info selected during registration. Falls back to User.location and/or
  User.name if necessary. These fields are for admin use only. If you are not a
  tournament admin or the participant being queried, these fields will be null.
  Do not display this information publicly.
  """
  contactInfo: ContactInfo

  """Unix time when participant was made"""
  createdAt: Timestamp

  """Participant Decks for Card Games"""
  decks(
    """Filter Decks to show only decks for a given Event ID."""
    eventId: ID
  ): [Deck]

  """Visible display name for a participant. TO visible only."""
  displayName: String @deprecated(reason: "Use User.name")

  """
  Email of the user, only available to admins within 18 months of tournament completion for tournament administrators.
  """
  email: String

  """Entrants associated with this Participant, if applicable"""
  entrants: [Entrant]

  """Doubles partners for this participant, if applicable"""
  eventPartners: [ParticipantEventPartner]

  """The events this participant registered for within a Tournament."""
  events: [Event]

  """
  Admin only field describing paid status for each event. If not an admin, this field will be null
  """
  eventsInfo: [EventInfo]

  """The tag that was used when the participant registered, e.g. Mang0"""
  gamerTag: String
  images(type: String): [Image]

  """Phone number of participant"""
  phoneNumber: String
  player: Player

  """Id of the Player"""
  playerId: Int @deprecated(reason: "Use the player field to get the player ID instead. This field is no longer maintained.")

  """The prefix that the user set for this Tournament, e.g. C9"""
  prefix: String

  """Admin only field of which selections were made during registration."""
  registrationSelections: [RegistrationSelection]

  """Current state of this participant's tournament registration"""
  registrationState: TournamentRegistrationState

  """
  Tournament Admin viewable field. Shows details for required social connections
  """
  requiredConnections: [ProfileAuthorization]

  """Streams associated with this Participant's tournament registration"""
  streams: [Streams]
  teams: [Team]

  """The tournament this participant is associated to."""
  tournament: Tournament

  """Admin only field of any transactions made during registration"""
  transactions: [UserTransaction]

  """Url for public attendee page"""
  url: String

  """The user this participant is associated to."""
  user: User

  """Id of user associated with this participant"""
  userId: Int @deprecated(reason: "Use the user field to get the user ID properly. This field is no longer maintained.")

  """Venue pass selections for this participant."""
  venuePasses: [RegistrationSelection]

  """If this participant is verified as actually being in the tournament"""
  verified: Boolean
}

type ParticipantAddedByInfo {
  addedByType: String
  addedBy: User
}

type AdminActions {
  name: String
  amount: Float
  date: Int
  paidByEmail: String
}

"""A message associated with some entity"""
type Note {
  id: ID

  """Note contents"""
  content: String

  """Timestamp of note creation"""
  createdAt: String

  """User Id of user who created this note"""
  createdBy: ID

  """Name of the user who created this note"""
  createdByName: String

  """Entity id associated with this note"""
  entityId: ID

  """Entity type associated with this note"""
  entityType: String

  """Timestamp of note update"""
  updatedAt: String
}

"""Name, address, etc"""
type ContactInfo {
  id: ID

  """Participant City Name"""
  city: String

  """Participant Country Name"""
  country: String

  """Participant Country (region) id"""
  countryId: Int
  name: String

  """First Name"""
  nameFirst: String

  """Last Name"""
  nameLast: String

  """Participant State Name"""
  state: String

  """Participant State (region) id"""
  stateId: Int

  """Zip or Postal Code"""
  zipcode: String
}

"""Deck of cards for a participant/entrant"""
type Deck {
  id: ID
  cardIds: [ID]
  cards: [Card]
  characterIds: JSON
  characters: [Character]
  connectedId: Int @deprecated(reason: "We should make an event / connectedEntity resolver if we want this")
  connectedType: String @deprecated(reason: "Every single connectedType we have is event")
  createdAt: Timestamp
  entrantId: Int @deprecated(reason: "We should make an entrant resolver if we want this")
  externalLink: String
  images: [Image]

  """True if the deck has no cards."""
  isEmpty: Boolean
  isPrimary: Boolean
  name: String
  participant: Participant
  participantId: Int @deprecated(reason: "We should make a participant resolver if we want this")
  title: String
  type: DeckType
  updatedAt: Timestamp
  valid: Boolean
}

"""A character in a videogame"""
type Character {
  id: ID
  images(type: String): [Image]

  """Name of Character"""
  name: String
}

"""Conveys the way that the contents of a deck are represented"""
enum DeckType {
  """Decks are represented as a collection of cards"""
  CARD

  """Decks are represented in one or more images"""
  IMAGE

  """Decks are represented on another site and linked"""
  EXTERNAL_LINK
}

type ParticipantEventPartner {
  eventId: ID
  player: Player
}

"""A player"""
type Player {
  id: ID

  """Paginated, filterable list of ScheduleItems"""
  adminSchedule(query: PlayerScheduleQuery): ScheduleItemConnection @deprecated(reason: "Use User.tournaments")
  color: String

  """Player's country"""
  country: String @deprecated(reason: "Use User.location")
  gamerTag: String

  """Time of player's last gamertag change"""
  gamerTagChangedAt: Timestamp

  """Player's images"""
  images(type: String): [Image] @deprecated(reason: "Use User.images")

  """Whether this Player is an attendee for X tournament"""
  isInTournament(tournamentId: ID): Boolean

  """The name of this player based on the player's display settings"""
  name: String @deprecated(reason: "Use User.name")

  """Player's nameDisplay field"""
  nameDisplay: Int @deprecated(reason: "Use User.publishingSettings.name")

  """All participants for a player"""
  participants: [Participant]
  prefix: String

  """
  Get a specific ProfileAuthorization given a type (see AuthorizationType)
  """
  profileAuthorization(type: AuthorizationType!): ProfileAuthorization

  """Most recent active & published rankings"""
  rankings(limit: Int, videogameId: ID): [PlayerRank]

  """Recent sets for this player."""
  recentSets(
    """Use this to get H2H history between two players"""
    opponentId: ID
  ): [Set] @deprecated(reason: "Use the sets field instead.")

  """Recent standings"""
  recentStandings(
    videogameId: ID

    """
    Number of recent standings to fetch. Default value is 3. Maximum value is 20.
    """
    limit: Int
  ): [Standing]

  """Player's region"""
  region: String @deprecated(reason: "Region no longer exists")

  """Set history for this player."""
  sets(
    page: Int
    perPage: Int

    """Supported filter options to filter down set results."""
    filters: SetFilters
  ): SetConnection

  """Player's state or province"""
  state: String @deprecated(reason: "Use User.location")

  """Player's twitch stream"""
  twitchStream: String @deprecated(reason: "Use User.profileAuthorizations")

  """Player's twitter handle"""
  twitterHandle: String @deprecated(reason: "Use User.profileAuthorizations")

  """Url for public user profile if player is linked to user"""
  url: String
  user: User
}

input PlayerScheduleQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: PlayerSchedulePaginationFilter
}

input PlayerSchedulePaginationFilter {
  past: Boolean
  upcoming: Boolean
  search: PaginationSearchType
  videogameId: [ID]
  tournamentView: String
}

type ScheduleItemConnection {
  pageInfo: PageInfo
  nodes: [ScheduleItem]
}

"""An item that represents part of a schedule"""
type ScheduleItem {
  id: ID

  """The end date of this schedule item in the format Y-m-d"""
  endDate: String
  entity: ScheduleItemEntity
  name: String

  """The start date of this schedule item in the format Y-m-d"""
  startDate: String
  type: String
}

"""The entity that this ScheduleItem is for"""
union ScheduleItemEntity = Tournament

"""A player's ranks"""
type PlayerRank {
  id: ID
  allRanksInSeries: [PlayerRank]
  characterMains: [Character]
  iteration: RankingIteration
  player: Player
  previousRank: Int

  """The player's placement on the ranking"""
  rank: Int
  title: String
  videogameId: ID
}

"""An iteration of a ranking series"""
type RankingIteration {
  id: ID
  description: String
  images(type: String): [Image]

  """Paginated, queryable list of player ranks"""
  playerRanks(query: PlayerRankPaginationQuery!): PlayerRankConnection
  publishedAt: Timestamp
  series: RankingSeries

  """URL for the ranking"""
  slug: String
  startAt: Timestamp
  title: String
}

input PlayerRankPaginationQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: PlayerRankPageFilter
}

input PlayerRankPageFilter {
  id: ID
  ids: [ID]
}

type PlayerRankConnection {
  pageInfo: PageInfo
  nodes: [PlayerRank]
}

"""A ranking series"""
type RankingSeries {
  id: ID
  images(type: String): [Image]
  iterations: [RankingIteration]
  locationDisplayName: String
  locationType: Int
  name: String
  slug: String
  url: String
  videogame: Videogame
  videogameId: Int
}

"""A videogame"""
type Videogame {
  id: ID
  approvedForOnlineFee: Boolean

  """All characters for this videogame"""
  characters: [Character]
  displayName: String

  """Tells whether this videogame has characters or not"""
  hasCharacters: Boolean
  hasDeckSupport: Boolean
  images(type: String): [Image]
  name: String

  """Platforms that this Videogame can be played on"""
  platforms: [Platform]
  satoriId: String
  slug: String

  """All stages for this videogame"""
  stages: [Stage]
  summary: String
}

"""A Platform that Videogames can be played on."""
type Platform {
  id: ID
  name: String

  """Networks that a videogame can be played on through this platform"""
  networks(videogameId: ID!): [Network]
}

"""A network through which a videogame can be played on a platform"""
type Network {
  id: ID
  connectName: String
  createdAt: Timestamp
  displayName: String
  updatedAt: Timestamp
}

"""Video Stage"""
type Stage {
  id: ID

  """Abbreviation for the videogame"""
  abbrev: String

  """Stage name"""
  name: String

  """Videogame ID"""
  videogameId: Int
}

input SetFilters {
  """Only return Sets for these Entrants"""
  entrantIds: [ID]

  """
  Only return Sets for this Entrant size. For example, to fetch 1v1 Sets only, filter by an entrantSize of 1
  """
  entrantSize: [Int]

  """Only return Sets that have an attached VOD"""
  hasVod: Boolean

  """
  Do not return empty Sets. For example, set this to true to filter out sets that are waiting for progressions.
  """
  hideEmpty: Boolean

  """Return sets that contain a bye"""
  showByes: Boolean

  """
  Only return Sets that are in an Online event. If omitted, Sets for both online and offline Events are returned
  """
  isEventOnline: Boolean

  """Only return Sets in certain geographical areas."""
  location: SetFilterLocation

  """Only return Sets for these Participants"""
  participantIds: [ID]

  """Only return Sets in these PhaseGroups"""
  phaseGroupIds: [ID]

  """Only return Sets in these Phases"""
  phaseIds: [ID]

  """Only return Sets in these Events"""
  eventIds: [ID]

  """Only return Sets in these Tournaments"""
  tournamentIds: [ID]

  """Only return Sets for these Players"""
  playerIds: [ID]

  """Only return Sets for these Rounds"""
  roundNumber: Int

  """Only returns Sets that are in these states"""
  state: [Int]

  """Only return Sets that are assigned to these Station IDs"""
  stationIds: [ID]

  """Only return Sets that are assigned to these Station numbers"""
  stationNumbers: [Int]

  """Only return sets created or updated since this timestamp"""
  updatedAfter: Timestamp
}

"""Filter Sets by geographical constraints."""
input SetFilterLocation {
  """Only return Sets in this state. Only applicable to US states"""
  state: String

  """
  Only return Sets in this country. Expects a valid two-letter country code
  """
  country: String
  distanceFrom: SetFilterLocationDistanceFrom
}

"""
Only return Sets that are a certain distance away from a specified point
"""
input SetFilterLocationDistanceFrom {
  """Point at which to perform distance calculation"""
  point: SetFilterLocationDistanceFromPoint

  """Distance from the point to include results in"""
  radius: String
}

input SetFilterLocationDistanceFromPoint {
  lat: Float
  lon: Float
}

type SetConnection {
  pageInfo: PageInfo
  nodes: [Set]
}

"""Information describing the status of a participant in an event"""
type EventInfo {
  """The entrantId of this entrant in this event."""
  entrantId: ID
  id: ID
  eventId: ID

  """Whether the event is unstarted, in-progress, or complete"""
  eventState: Int

  """The name of this entrant in this event."""
  name: String

  """Total number of entrants in this event."""
  numEntrants: Int

  """Did this participant pay for this event"""
  paid: Boolean
  placement: Int

  """The event slug."""
  slug: String
}

"""A selection made during registration"""
type RegistrationSelection {
  id: ID
  additional: RegistrationSelectionAdditional
  balance: Float

  """
  The type of the option for this selection. i.e. `event` or `additional`
  """
  optionType: String

  """The registration value associated with this selection"""
  regValue: RegistrationValue
  valueId: Int
}

union RegistrationSelectionAdditional = RegistrationSelectionAdditionalStandard | RegistrationSelectionAdditionalLeagueOfLegends

type RegistrationSelectionAdditionalStandard {
  value: String
  steamName: String
  epicAccountId: String
  battlenetAccountId: String
  riotAccountId: String
  activeNetwork: String
  token: String
}

type RegistrationSelectionAdditionalLeagueOfLegends {
  value: NetworkSelectionLeagueOfLegends
  activeNetwork: String
  steamName: String
  token: String
}

type NetworkSelectionLeagueOfLegends {
  name: String
  server: String
}

"""A possible choice for a registration option"""
type RegistrationValue {
  """If the RegistrationOption specifies a fee, this is the value"""
  fee: Float
  id: ID
  additional: JSON

  """If the RegistrationOption specifies an end time, this is the value"""
  endAt: Timestamp
  name: String

  """The ID of the RegistrationOption that this value is for"""
  optionId: ID

  """The type of domain object that this value references"""
  optionType: String

  """The ID of the domain object that this value references"""
  optionTypeId: ID

  """Contains Entity Type and Entity ID"""
  requires: [JSON]

  """If the RegistrationOption specifies a start time, this is the value"""
  startAt: Timestamp

  """How many of this value have been selected by participants?"""
  valueConsumed: Int

  """If the RegistrationOption specifies a limit, this is the value"""
  valueLimit: Int

  """
  TODO Not entirely sure what this means for a RegistrationValue, RegistrationOption also has a visible flag
  """
  visible: Boolean
}

"""State of a user's registration for a tournament"""
enum TournamentRegistrationState {
  """User is not registered for tournament"""
  UNREGISTERED

  """
  This participant was manually added by organizer and is not connected to a user account
  """
  ANONYMOUS

  """
  User was manually added to tournament by organizer and has not verified their participation
  """
  UNVERIFIED

  """User is registered for tournament and has verified their participation"""
  VERIFIED
}

"""Tournament Stream"""
type Streams {
  id: ID
  enabled: Boolean
  eventId: Int @deprecated(reason: "We should add an event resolver if we want this")
  followerCount: Int
  isOnline: Boolean
  numSetups: Int
  parentStreamId: Int
  removesTasks: Boolean
  shortName: String
  streamGame: String
  streamId: String
  streamLogo: String
  streamName: String
  streamSource: StreamSource
  streamStatus: String
  streamType: Int
  streamTypeId: Int

  """URL for stream, defaults to EMBED type."""
  streamUrl(streamUrlType: StreamUrlType = EMBED): String
  tournamentId: Int @deprecated(reason: "We should add a tournament resolver if we want this")
}

"""Represents the source of a stream"""
enum StreamSource {
  """Stream is on twitch.tv channel"""
  TWITCH

  """Stream is on smashcast.tv channel"""
  HITBOX

  """Stream is on a stream.me channel"""
  STREAMME

  """Stream is on a mixer.com channel"""
  MIXER

  """Stream is on a youtube.com channel"""
  YOUTUBE
}

"""Represents an embed vs page."""
enum StreamUrlType {
  """Direct link to Embed: player.twitch.tv/?channel=..."""
  EMBED

  """
  Direct link to Page: twitch.tv/..."
  """
  PAGE
}

"""Information about a payment made by a user"""
type UserTransaction {
  createdAt: Timestamp
  id: ID
  currency: String
  externalId: String
  externalType: String
  lineItems: [LineItem]
  livemode: Boolean

  """Total cost of all line items within the transaction"""
  totalCost: Float
  value: Float
}

"""Each individual item purchased during a transaction"""
type LineItem {
  id: ID
  cost: Float
  externalTypeId: Int
  name: String
  type: String
}

"""Membership status of a team member"""
enum TeamMemberStatus {
  """"""
  UNKNOWN

  """"""
  ACCEPTED

  """"""
  INVITED

  """"""
  REQUEST

  """"""
  ALUM

  """"""
  HIATUS

  """"""
  OPEN_SPOT
}

"""A summary of an action taken by an entity"""
type ActionSummary {
  allowedAt: Timestamp
  allowedUntil: Timestamp
  isAllowed: Boolean
  limit: Int
  name: String
  used: Int
}

"""Global Team"""
type GlobalTeam implements Team {
  id: ID
  acceptedMembers: [TeamMember] @deprecated(reason: "Use the new members resolver with just accepted status")
  adminUrl(tab: String): String
  bio: String

  """Does this team have a complete set of accepted members"""
  complete: Boolean

  """
  Uniquely identifying token for team. Same as the hashed part of the slug
  """
  discriminator: String
  entrant: Entrant @deprecated(reason: "Use the entrant field off the EventTeam type")
  entrantId: Int @deprecated(reason: "Use entrant on EventTeam")
  event: Event @deprecated(reason: "Use the event field off the EventTeam type")
  eventId: Int @deprecated(reason: "Use event on EventTeam")
  eventTeams(query: TeamPaginationQuery): EventTeamConnection
  images(type: String): [Image]

  """
  Url that contains the inviteCode assigned to the team. This is the link team admins can share with new members.
  """
  inviteLink: String
  isCurrentUserAdmin: Boolean

  """Are join requests allowed for the team?"""
  joinRequestsAllowed: Boolean

  """Leagues-level teams for leagues this team is competing in"""
  leagueTeams(query: TeamPaginationQuery): EventTeamConnection

  """Leagues this team is competing in"""
  leagues(query: TeamPaginationQuery): LeagueConnection
  members(status: [TeamMemberStatus]): [TeamMember]
  name: String
  slug: String

  """Tournaments this team is competing in"""
  tournaments(query: TeamTournamentsPaginationQuery): TournamentConnection
  type: Int
  url(tab: String): String
  userMember(
    """User ID to get member for. If null, defaults to the current user."""
    userId: ID = null
  ): TeamMember
  verified: Boolean
  videogame: Videogame
}

input TeamPaginationQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: TeamPaginationFilter
}

input TeamPaginationFilter {
  globalTeamId: ID
  eventState: ActivityState
  eventId: ID
  eventIds: [ID]
  minEntrantCount: Int
  maxEntrantCount: Int
  search: PaginationSearchType
  type: Int
  tournamentId: ID
  memberStatus: [TeamMemberStatus]
  videogameId: [ID]
  isLeague: Boolean
  upcoming: Boolean
  past: Boolean
  rosterComplete: Boolean
  rosterIncomplete: Boolean
}

"""Represents the state of an activity"""
enum ActivityState {
  """Activity is created"""
  CREATED

  """Activity is active or in progress"""
  ACTIVE

  """Activity is done"""
  COMPLETED

  """Activity is ready to be started"""
  READY

  """Activity is invalid"""
  INVALID

  """Activity, like a set, has been called to start"""
  CALLED

  """Activity is queued to run"""
  QUEUED
}

type EventTeamConnection {
  pageInfo: PageInfo
  nodes: [EventTeam]
}

type LeagueConnection {
  pageInfo: PageInfo
  nodes: [League]
}

"""A league"""
type League {
  id: ID
  addrState: String

  """Build Tournament admin URL"""
  adminUrl(
    """Tournament admin tab to add to URL"""
    tab: String

    """
    Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
    """
    relative: Boolean = true
  ): String
  approved: Boolean

  """Attendee requirements for this tournament"""
  attendeeFieldConfig: JSON
  circuitPhaseGroup: CircuitPhaseGroup
  city: String
  contactEmail: String @deprecated(reason: "Use primaryContact fields")
  contactPhone: String @deprecated(reason: "Use primaryContact fields")
  contactTwitter: String @deprecated(reason: "Use primaryContact fields")
  countryCode: String

  """When the tournament was created (unix timestamp)"""
  createdAt: Timestamp
  currency: String
  customMarkdown: JSON @deprecated(reason: "No longer used")
  defaultTab: String
  details: String @deprecated(reason: "No longer used")
  emailDirections: String
  emailInstructions: String
  emailNote: String

  """When the tournament ends"""
  endAt: Timestamp
  entrantCount: Int
  eventCount: Int
  eventOwners(query: EventOwnersQuery): EventOwnerConnection

  """When does event registration close"""
  eventRegistrationClosesAt: Timestamp

  """
  Get all event level teams in this tournament for a given global team or player
  """
  eventTeams(globalTeamId: ID, playerId: ID): [EventTeam]

  """Paginated list of events in a league"""
  events(query: LeagueEventsQuery): EventConnection
  finalEvent: Event @deprecated(reason: "No longer used")

  """Hacked "progression" into this final event"""
  finalEventId: Int @deprecated(reason: "No longer used")
  generatedTabs: JSON
  gettingThere: String @deprecated(reason: "No longer used")

  """True if tournament has at least one offline event"""
  hasOfflineEvents: Boolean
  hasOnlineEvents: Boolean
  hashtag: String

  """Whether or not to hide the admins"""
  hideAdmins: Boolean
  images(type: String): [Image]
  includeQRCheckIn: Boolean
  includeQRCode: Boolean

  """Whether this league's events are all centralized by the admin"""
  isCentralized: Boolean

  """True if tournament has at least one online event"""
  isOnline: Boolean
  lat: Float
  links: TournamentLinks
  lng: Float
  mapsPlaceId: String
  merchantConnectionId: Int
  minimumRequirements: JSON

  """The tournament name"""
  name: String

  """Get nomination event linked to this tournament"""
  nominationEvent: NominationEvent

  """Whether to send admin emails when a new person registers"""
  notifyAdmins: Boolean

  """Top X number of people in the standings who progress to final event"""
  numProgressingToFinalEvent: Int @deprecated(reason: "No longer used")
  numUniquePlayers: Int
  onsitePaymentMode: String
  ownerId: Int @deprecated(reason: "We should add an owner resolver if we need this")
  parentLeague: League
  paypalMode: String
  postalCode: String
  primaryContact: String
  primaryContactType: String
  prizes: String @deprecated(reason: "No longer used")
  profileLinks(
    """Hub id to filter profile links on"""
    hubId: ID
  ): [ProfileLink]

  """Publishing settings for this tournament"""
  publishing: JSON
  qrCodeRedirect: String
  qrCodeRedirectType: String

  """The region of the tournament"""
  region: String @deprecated(reason: "No longer used")

  """When does registration for the tournament end"""
  registrationClosesAt: Timestamp

  """RegistrationOptions for this Tournament"""
  registrationOptions(
    """
    Filter RegistrationOptions by fieldType. Omit this argument to return all RegistrationOptions.
    """
    optionType: String
  ): [RegistrationOption]

  """
  The period of time before the start date to send a reminder email to registrants
  """
  reminderInterval: Int
  requests(
    """Requests in this direction"""
    direction: RequestDirection!
    query: LeagueRequestQuery
  ): ProfileRequestConnection
  rules: String

  """The short slug used to form the url"""
  shortSlug: String

  """Whether standings for this league should be visible"""
  showStandings: Boolean
  slug: String
  standing(
    """Entrant in an event connected to this league"""
    entrantId: ID!
  ): Standing
  standingGroup: StandingGroup

  """Paginated list of standings"""
  standings(query: StandingGroupStandingPageFilter): StandingConnection

  """When the tournament Starts"""
  startAt: Timestamp

  """
  State of the tournament, can be ActivityState::CREATED, ActivityState::ACTIVE, or ActivityState::COMPLETED
  """
  state: Int
  stripeMode: String
  stripeUserId: String
  subleagues: [League]

  """When is the team creation deadline"""
  teamCreationClosesAt: Timestamp
  tiers: [EventTier]

  """The timezone of the tournament"""
  timezone: String

  """The type of tournament from TournamentType"""
  tournamentType: Int

  """When the tournament was last modified (unix timestamp)"""
  updatedAt: Timestamp

  """Build Tournament URL"""
  url(
    """Tournament tab to add to URL"""
    tab: String

    """
    Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
    """
    relative: Boolean = true
  ): String
  userEligibleEvents: [UserEligibleEvents]
  venueAddress: String
  venueName: String
  videogames: [Videogame]
}

"""A circuit type phase group"""
type CircuitPhaseGroup {
  id: ID

  """The bracket type of this group's phase."""
  bracketType: BracketType

  """URL for this phase groups's bracket."""
  bracketUrl: String
  checkInFinalizeAction: String
  checkInState: String

  """The sets of current round of a phase group"""
  currentRoundSets: [Set]

  """Unique identifier for this group within the context of its phase"""
  displayIdentifier: String

  """Event check in groups that the phase group is linked to"""
  eventCheckInGroup: EventCheckInGroup
  firebasePath: String

  """
  For the given phase group, this is the start time of the first round that occurs in the group.
  """
  firstRoundTime: Timestamp
  groupTypeId: Int

  """
  Matchmaking settings for this Phase Group. Should only be used in queries for
  Phase Groups that are known to be of the Matchmaking bracket type.
  """
  matchmakingSettings: JSON
  numRounds: Int

  """The number of seeds for a phase group."""
  numSeeds(checkInState: Int): Int
  oldSets(
    """Limit to Sets in the current round"""
    currentRoundOnly: Boolean = false
  ): [Set]
  paginatedSeeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection @deprecated(reason: "Please use 'seeds', which is now paginated")

  """Paginated sets on this phaseGroup"""
  paginatedSets(
    page: Int
    perPage: Int

    """How to sort these sets"""
    sortType: SetSortType

    """Supported filter options to filter down set results."""
    filters: SetFilters
  ): SetConnection @deprecated(reason: "Please use 'sets', which is now paginated")

  """Percentage of matches completed for this phase group"""
  percentComplete: Int

  """The phase associated with this phase group"""
  phase: Phase
  phaseId: Int @deprecated(reason: "Use phase")
  pointMappingGroups: [PointMappingGroup]

  """The progressions out of this phase group"""
  progressionsOut: [Progression]
  raceConfig: JSON
  roundDisplayNames: JSON @deprecated(reason: "This is the wrong API for getting round titles. We need to put more work into the phaseGroup.rounds resolver to make it useful.")
  rounds: [Round]
  seedMap: JSON

  """Paginated seeds for this phase group"""
  seeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection

  """Paginated sets on this phaseGroup"""
  sets(
    page: Int
    perPage: Int

    """How to sort these sets"""
    sortType: SetSortType

    """Supported filter options to filter down set results."""
    filters: SetFilters
  ): SetConnection
  standingGroup: StandingGroup

  """List of StandingGroups, or Leaderboards, for this circuit"""
  standingGroups: [StandingGroup]

  """
  Paginated list of standing points attached to this circuit's default standing group
  """
  standingPoints(query: StandingPointsPaginationQuery): StandingPointsConnection

  """Paginated list of standings"""
  standings(query: StandingGroupStandingPageFilter): StandingConnection

  """
  Unix time the group is scheduled to start. This info could also be on the wave instead.
  """
  startAt: Timestamp
  state: Int

  """Paginated stations on this phaseGroup"""
  stations(query: StationFilter): StationsConnection
  tiebreakOrder: JSON
  unpaginatedSeeds: [Seed]

  """
  URL for the phase group. Optionally, build URL for resource under the phase group
  """
  url(
    """Phase group (brackets) tab to build URL for"""
    tab: String

    """
    Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
    """
    relative: Boolean = true
  ): String

  """
  Gets seeds in this phaseGroup for a particular user. Normally this will only
  be 0 or 1 seed. There might be weird cases where someone has more seeds
  """
  userSeeds(
    """User ID to get sets for. If null, will default to current user."""
    userId: ID
  ): [Seed]

  """The current user's tasks for this phase group"""
  userTasks: [Task]
  wave: Wave
  waveId: Int @deprecated(reason: "Use wave")
}

"""Group of check in enabled phase groups for a given start time"""
type EventCheckInGroup {
  id: ID
  checkInFinalized: Boolean
  createdAt: Timestamp

  """The event the check in group is part of"""
  event: Event
  eventId: Int
  firebasePath: String
  firebasePrefix: String

  """Number of phase groups linked to this check in group"""
  numPhaseGroups: Int
  startAt: Timestamp
  updatedAt: Timestamp
}

input SeedPaginationQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: SeedPageFilter
}

input SeedPageFilter {
  id: ID
  entrantName: String
  checkInState: [Int]
  phaseGroupId: [ID]
  eventCheckInGroupId: ID
  phaseId: [ID]
  eventId: ID
  search: PaginationSearchType
}

type SeedConnection {
  pageInfo: PageInfo
  nodes: [Seed]
}

"""Different sort type configurations used when displaying multiple sets"""
enum SetSortType {
  """Sets will not be sorted."""
  NONE

  """
  Sets are sorted in the suggested order that they be called to be played. The order of completed sets is reversed.
  """
  CALL_ORDER

  """
  Sets are sorted by relevancy dependent on the state and progress of the event.
  """
  MAGIC

  """Sets are sorted in the order that they were started."""
  RECENT

  """Deprecated. This is equivalent to CALL_ORDER"""
  STANDARD

  """Sets sorted by round and identifier"""
  ROUND
}

"""
A connection between a placement in an origin phase group to a destination seed.
"""
type Progression {
  id: ID
  originOrder: Int
  originPhase: Phase
  originPhaseGroup: PhaseGroup
  originPlacement: Int
  placeholderName: String
}

"""A round within a phase group"""
type Round {
  id: ID

  """
  If applicable, bestOf is the number of games
  									one must win a majority out of to win a set in this round
  """
  bestOf: Int

  """Indicates this round's order in the phase group"""
  number: Int

  """The time that this round is scheduled to start at"""
  startAt: Timestamp
}

input StandingPointsPaginationQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: StandingPointsPageFilter
}

input StandingPointsPageFilter {
  id: ID
  isManual: Boolean
  search: PaginationSearchType
}

type StandingPointsConnection {
  pageInfo: PageInfo
  nodes: [StandingPoints]
}

"""Points values that can belong to a standing."""
type StandingPoints {
  id: ID
  description: String

  """The entrant these points belong to (if applicable)"""
  entrant: Entrant

  """The event these points belongs to (if applicable)"""
  event: Event
  internalNotes: String
  isManual: Boolean
  isVerified: Boolean
  quantity: Float
  sourceEntrant: Entrant
  sourceId: Int
  sourceType: String
  standing: Int

  """One off node for FFA display tables"""
  stats: JSON
}

input StandingGroupStandingPageFilter {
  page: Int
  perPage: Int
  sortBy: String
}

input StationFilter {
  page: Int
  perPage: Int
}

type StationsConnection {
  pageInfo: PageInfo
  nodes: [Stations]
}

"""Stations, such as a stream setup, at an event"""
type Stations {
  id: ID
  canAutoAssign: Boolean
  clusterId: Int @deprecated(reason: "We should add a cluster resolver if we want this")
  clusterNumber: String
  clusterPrefix: Int
  createdAt: Timestamp
  enabled: Boolean
  eventId: Int @deprecated(reason: "We should add an event resolver if we want this")
  followerCount: Int @deprecated(reason: "No longer used")
  identifier: Int
  isOnline: Boolean @deprecated(reason: "No longer used")
  numSetups: Int
  number: Int
  prefix: String
  queue: JSON
  queueDepth: Int
  state: Int

  """Tournament event stream for a station"""
  stream: Streams
  streamGame: String @deprecated(reason: "No longer used")
  streamId: Int @deprecated(reason: "Use stream")
  streamLogo: String @deprecated(reason: "No longer used")
  streamName: String @deprecated(reason: "No longer used")
  streamSource: Int @deprecated(reason: "No longer used")
  streamStatus: String @deprecated(reason: "No longer used")
  streamType: Int @deprecated(reason: "No longer used")
  streamTypeId: Int @deprecated(reason: "No longer used")
  tournamentId: Int @deprecated(reason: "Use tournament")
  updatedAt: Timestamp
}

"""Represents a task for a user to complete for some entity"""
type Task {
  id: ID
  cta: JSON
  description: String
  dismissed: Boolean
  entity: TaskEntity
  entityId: ID @deprecated(reason: "Use entity")
  entityType: String @deprecated(reason: "Use entity")
  featureId: ID @deprecated(reason: "Use systemId now")
  meta: JSON
  player: Player @deprecated(reason: "Only works for sets. Use entity resolver instead to connect to a player")
  prereqs: JSON
  priority: Int
  sortOrder: Int
  state: Int
  systemId: Int
  timer: TaskTimer
  title: String
  type: String
}

"""The entity that generated this task"""
union TaskEntity = Set | Event | PhaseGroup

"""Represents a timer or deadline for a task to be acted on."""
type TaskTimer {
  description: String
  endAt: Timestamp
  startAt: Timestamp
  title: String
}

"""A wave in a tournament"""
type Wave {
  id: ID

  """The Wave Identifier"""
  identifier: String

  """Unix time the wave is scheduled to start."""
  startAt: Timestamp
}

input EventOwnersQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
}

type EventOwnerConnection {
  pageInfo: PageInfo
  nodes: [EventOwner]
}

"""Name and Gamertag of the owner of an event in a league"""
type EventOwner {
  eventId: ID
  email: String
  gamerTag: String
  fullName: String
}

input LeagueEventsQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: LeagueEventsFilter
}

input LeagueEventsFilter {
  search: PaginationSearchType
  pointMappingGroupIds: [ID]
  tierIds: [ID]
  userId: ID
  upcoming: Boolean
  leagueEntrantId: ID
}

type TournamentLinks {
  facebook: String
  discord: String
}

"""A nomination event"""
type NominationEvent {
  id: ID
  endAt: Timestamp
  hashtag: String
  headerItems: [NominationHeaderItems]
  headerSettings: JSON
  images(type: String): [Image]
  name: String
  nominationFields: NominationFields
  nominationSettings: NominationSettings
  numToProgress: Int
  optInEndAt: Timestamp
  optInStartAt: Timestamp
  startAt: Timestamp
  tournamentId: ID
  twitterHandle: String
}

type NominationHeaderItems {
  title: String
  description: String
  displayOrder: Int
  hasOptInBtn: Boolean
}

type NominationFields {
  hasAsk: Boolean
}

type NominationSettings {
  type: String
}

"""Links an owner profile to the profile it owns."""
type ProfileLink {
  id: ID
  isFeatured: Boolean
  linkType: Int
  ownerId: Int
  ownerType: String
  profileId: Int

  """Profile tags attached to this profile link."""
  profileTags: [ProfileTag]
  profileType: String
}

"""A tag owned by a profile. Currently only hubs can own tags"""
type ProfileTag {
  id: ID
  name: String
  ownerId: Int
  ownerType: String
}

"""
Contains fields to be filled out during registration. The fields themselves are
RegistrationValues, and the actual selected value is a RegistrationSelection.
"""
type RegistrationOption {
  id: ID
  createdAt: Timestamp
  description: String
  fieldType: String
  isSubfield: Boolean
  name: String
  optionLimit: Int
  optionType: String
  required: Boolean
  updatedAt: Timestamp

  """List of RegistrationValues for this option"""
  values: [RegistrationValue]
  visible: Boolean
}

"""Incoming or Outgoing request"""
enum RequestDirection {
  """"""
  INCOMING

  """"""
  OUTGOING
}

input LeagueRequestQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: LeagueRequestFilter
}

input LeagueRequestFilter {
  status: [RequestStatus]

  """Filter on the other type. i.e. requester/recipient"""
  entityType: String

  """Filter on the specific entity. Should also specify entityType"""
  entityId: ID
  location: LocationFilterType
  search: PaginationSearchType
}

type ProfileRequestConnection {
  pageInfo: PageInfo
  nodes: [ProfileRequest]
}

"""Request object for transactions between profile types"""
type ProfileRequest {
  id: ID

  """Link that the user must follow in order to accept the request"""
  acceptUrl: String

  """Connection entity associated with this request"""
  connection: RequestConnection

  """Unix time of when the request was created"""
  createdAt: Timestamp

  """Entity receiving this request"""
  recipient: RequestEntity
  requestData: JSON

  """User that created this request"""
  requestedByUser: User

  """Entity creating this request"""
  requester: RequestEntity

  """Profile type of object that initiated the request"""
  requesterType: String

  """Status of the request"""
  status: RequestStatus

  """Type of profile request"""
  type: Int

  """Unix time of when the request was updated"""
  updatedAt: Timestamp
}

union RequestConnection = Participant | EventTier | Role | TeamMember | GlobalTeam

union RequestEntity = Tournament | User | League | Event | Hub | GlobalTeam | EventTeam

"""A profile that can contain other profiles within it"""
type Hub {
  id: ID
  adminUrl(tab: String): String
  bio: String
  city: String
  countryCode: String
  createdAt: Timestamp

  """Number of users following this hub"""
  followerCount: Int
  fullAddress: String
  images(type: String): [Image]
  isCurrentUserAdmin: Boolean
  lat: Float

  """Leagues linked to this hub"""
  leagues(query: HubTournamentsPaginationQuery): LeagueConnection
  lng: Float
  mapsPlaceId: String
  name: String
  postalCode: String
  primaryContact: String
  primaryContactType: String

  """Profile links attached to this hub"""
  profileLinks(tagName: [String]): [ProfileLink]

  """Linked profile tags created for this hub."""
  profileTags: [ProfileTag]
  publishingSettings: HubPublishingSettings

  """Get roles for this profile"""
  roles(page: Int, perPage: Int, includeUnconfirmed: Boolean): RoleConnection
  slug: String
  state: String

  """Tournaments linked to this hub"""
  tournaments(query: HubTournamentsPaginationQuery): TournamentConnection
  updatedAt: Timestamp
  url(tab: String): String

  """Alias for fullAddress field."""
  venueAddress: String
}

input HubTournamentsPaginationQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: HubTournamentsPaginationFilter
}

input HubTournamentsPaginationFilter {
  search: PaginationSearchType
  isFeatured: Boolean
  isCurrentUserAdmin: Boolean
  upcoming: Boolean
  videogameIds: [ID]
}

"""Publishing settings for a hub"""
type HubPublishingSettings {
  followerCount: FollowerCountPublishingState
  publishing: ProfilePublishingState
}

"""Publishing settings for a hub's follower count"""
enum FollowerCountPublishingState {
  """"""
  PRIVATE

  """"""
  PUBLIC
}

"""Publishing state for the profile"""
enum ProfilePublishingState {
  """"""
  PRIVATE

  """"""
  LINK_ONLY

  """"""
  PUBLIC
}

type RoleConnection {
  pageInfo: PageInfo
  nodes: [Role]
}

type TournamentConnection {
  pageInfo: PageInfo
  nodes: [Tournament]
}

"""
Events that the current user has permissions to submit in a league application
"""
type UserEligibleEvents {
  event: Event
  tier: EventTier
}

input TeamTournamentsPaginationQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: TeamTournamentsPaginationFilter
}

input TeamTournamentsPaginationFilter {
  past: Boolean
  upcoming: Boolean
  search: PaginationSearchType
}

"""
A set of restrictions for an entity (i.e. team) in order to be a member of a container (i.e. event)
"""
type EntityRestriction {
  actionWindows(
    """Only return action windows in this state"""
    state: ActionWindowState
  ): [ActionWindow]
  id: ID
  container: RestrictionContainer
  description: String
  name: String
  restrictedEntityType: String
  state: Int
}

"""A state representing whether actions can currently be made"""
enum ActionWindowState {
  """"""
  UPCOMING

  """"""
  OPEN

  """"""
  CLOSED
}

"""A window of time that an ActionSet can be taken"""
type ActionWindow {
  id: ID
  actionSet: ActionSet
  endAt: Timestamp
  startAt: Timestamp
  state: ActionWindowState
}

"""A set of actions available for an entity to take"""
interface ActionSet {
  id: ID
  actions(isAllowed: Boolean): [Action]
}

"""A restricted action definition"""
type Action {
  isAllowed: Boolean
  limit: Int
  name: String
}

"""The object imposing a restriction on other entities"""
union RestrictionContainer = Event

"""Team roster size requirements"""
type TeamRosterSize {
  maxAlternates: Int
  maxPlayers: Int
  minAlternates: Int
  minPlayers: Int
}

input EventFilter {
  videogameId: [ID]
  type: [Int]
  published: Boolean
  id: ID
  ids: [ID]
  slug: String
  fantasyEventId: ID
  fantasyRosterHash: String
}

input ParticipantPaginationQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: ParticipantPageFilter
}

input ParticipantPageFilter {
  id: ID
  ids: [ID]
  eventIds: [ID]
  search: PaginationSearchType
  gamerTag: String
  unpaid: Boolean
  incompleteTeam: Boolean
  missingDeck: Boolean
  checkedIn: Boolean
  notCheckedIn: Boolean
}

type ParticipantConnection {
  pageInfo: PageInfo
  nodes: [Participant]
}

input TournamentRequestQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: TournamentRequestFilter
}

input TournamentRequestFilter {
  status: [RequestStatus]

  """Filter on the other type. i.e. requester/recipient"""
  entityType: String

  """Filter on the specific entity. Should also specify entityType"""
  entityId: ID
  location: LocationFilterType
  search: PaginationSearchType
}

input ShopProductFilter {
  type: Int
  addressRequired: Boolean
  hasVariants: Boolean
}

"""Shop Product"""
type ShopProduct {
  id: ID
  description: String
  images(type: String): [Image]
  name: String
  shop: Shop
  type: Int
}

"""A shop"""
type Shop {
  id: ID
  levels(query: ShopLevelsQuery): ShopLevelConnection
  messages(query: ShopOrderMessagesQuery): ShopOrderMessageConnection
  name: String
  slug: String
  url: String
}

input ShopLevelsQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
}

type ShopLevelConnection {
  pageInfo: PageInfo
  nodes: [ShopLevel]
}

"""A shop level"""
type ShopLevel {
  id: ID
  currAmount: Float
  description: String
  endAt: Timestamp
  goalAmount: Float
  images(type: String): [Image]
  name: String
  votingConfig: ShopVotingOptionConfig
  votingValues: [ShopVotingOptionValue]
}

"""A shop level voting option config"""
type ShopVotingOptionConfig {
  id: ID
  currAmount: Float
  description: String
  goalAmount: Float
  name: String
  numSelected: Int
  voteRatio: Float
}

"""A shop level voting option value"""
type ShopVotingOptionValue {
  id: ID
  name: String
  subname: String
}

input ShopOrderMessagesQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
}

type ShopOrderMessageConnection {
  pageInfo: PageInfo
  nodes: [ShopOrderMessage]
}

"""The message and player info for a shop order"""
type ShopOrderMessage {
  id: ID

  """The player's gamertag. Returns null if anonymous message type"""
  gamertag: String

  """The order message"""
  message: String

  """The player's name. Returns null unless name & tag display is selected"""
  name: String

  """The player who left the comment"""
  player: Player

  """The total order amount"""
  total: Float
}

"""A Stream queue object"""
type StreamQueue {
  id: String

  """The sets on the stream"""
  sets: [Set]

  """The stream on the queue"""
  stream: Streams
}

type TeamConnection {
  pageInfo: PageInfo
  nodes: [Team]
}

"""Event Prizing"""
interface EventPrizing {
  id: ID
  prizingType: PrizingType
}

"""Type of prizing"""
enum PrizingType {
  """"""
  PERCENTAGE

  """"""
  FIXED_AMOUNT

  """"""
  PRODUCT

  """"""
  DEFAULT_PRIZING
}

"""
Any stats related to this standing. This type is experimental and very likely to change in the future.
"""
type StandingStats {
  score: Score
}

"""
The score that led to this standing being awarded. The meaning of this field can
vary by standing type and is not used for some standing types.
"""
type Score {
  """
  The name of this score. e.g. "Kills" or "Stocks"
  """
  label: String

  """The raw score value"""
  value: Float

  """
  Like value, but formatted for race format events. Formatted according to the race config for the front end to use.
  """
  displayValue: String
}

"""
Describes a source for an entrant in a set. Generally the source is either from
a winner/loser of a set in this phase group, or a seed if this is a progression
"""
type SetEntrantSource {
  """The type of this source. e.g. set, seed"""
  type: String!

  """The ID of the type of this source. e.g. set ID, seed ID, etc."""
  typeId: ID

  """The condition of this source. e.g. winner, loser, etc."""
  condition: String

  """
  Human readable string for the condition. e.g. "Winner of Set #1234" or "Seed #1"
  """
  conditionString: String
}

"""
A slot in a set where a seed currently or will eventually exist in order to participate in the set.
"""
type SetSlot {
  destinationSlot: SetSlot
  id: ID
  entrant: Entrant
  isFilled: Boolean

  """true if this slot progressed from the given setId"""
  isFromSet(setId: ID): Boolean
  originProgression: Progression
  originSet: Set

  """Pairs with prereqType, is the ID of the prereq."""
  prereqId: String

  """
  Given a set prereq type, defines the placement required in the origin set to end up in this slot.
  """
  prereqPlacement: Int

  """Describes where the entity in this slot comes from."""
  prereqType: String
  seed: Seed

  """
  Will be filled with a seedId once it is confirmed who will be participating in this slot.
  """
  seedId: Int @deprecated(reason: "Use seed")
  set: Set
  setId: ID @deprecated(reason: "Use set")

  """The index of the slot. Unique per set."""
  slotIndex: Int

  """
  The standing within this set for the seed currently assigned to this slot.
  """
  standing: Standing
}

"""A game represents a single game within a set."""
type Game {
  id: ID

  """Gets the users self reported stats for this game"""
  currentUserReportedStats: JSON

  """Score of entrant 1. For smash, this is equivalent to stocks remaining."""
  entrant1Score: Int

  """Score of entrant 2. For smash, this is equivalent to stocks remaining."""
  entrant2Score: Int

  """Aggregates self reported stats for all entrants in this game"""
  entrantReportedStats: JSON
  images(type: String): [Image]

  """The API Game that this was game was linked to if any"""
  linkedApiGame: JSON
  orderNum: Int

  """Selections for this game such as character, etc."""
  selections: [GameSelection]
  setId: Int @deprecated(reason: "We should add a set resolver if we need this")

  """The stage that this game was played on (if applicable)"""
  stage: Stage
  state: Int

  """The stats as computed by the UIMapping for this game."""
  stats: JSON
  uiMapping: UIMapping
  winnerId: Int
}

"""A selection for this game. i.e. character/stage selection, etc"""
type GameSelection {
  """The entrant who this selection is for"""
  entrant: Entrant
  id: ID

  """If this is a character selection, returns the selected character."""
  character: Character
  entrantId: Int @deprecated(reason: "We should add an entrant resolver if we need this")
  orderNum: Int

  """
  The participant who this selection is for. This is only populated if there are
  selections for multiple participants of a single entrant
  """
  participant: Participant
  participantId: Int @deprecated(reason: "We should add a participant resolver if we need this")
  selectionType: GameSelectionType
  selectionValue: Int
}

"""The type of selection i.e. is it for a character or something else"""
enum GameSelectionType {
  """Character selection"""
  CHARACTER
}

"""
Describes the means by which data is fetched from a user via a UI definition.
Also defines how the data returned from the UI maps to a schema.
"""
type UIMapping {
  id: ID

  """
  Data generated from the UI mapping and the scope it was fetched in. Use this to populate UI data.
  """
  data: JSON
  entries: [UIMappingEntry]
  videogameId: ID

  """
  The type of view described by this UI Mapping. Can be used to get specific UI Mapping types on the FE.
  """
  viewType: String
}

"""Defines a single component and where it maps to in the schema."""
type UIMappingEntry {
  component: Component

  """The key of this entry. Should be unique within its hierarchy."""
  key: String

  """The name of this entry. Can be used as a column name, for example."""
  name: String
}

"""Defines everything required to show a dynamic UI element."""
type Component {
  """The name of component to render"""
  componentName: String

  """
  Prop values to pass to the dynamic component. Props structure can have many
  different fields and types so it is not strongly typed.
  """
  props: JSON
}

"""[DEPRECATED] An action to do for a match"""
type OldSetTask {
  id: ID
  action: String
  active: Boolean
  activeAt: Timestamp
  dqAt: Timestamp
  entrantId: Int
  images(type: String): [Image]
  isCompleted: Boolean
  metadata: JSON
  taskOrder: Int
  type: Int
}

input SlotPageFilter {
  page: Int
  perPage: Int
}

type SetSlotConnection {
  pageInfo: PageInfo
  nodes: [SetSlot]
}

"""A Profile Task"""
type ProfileTask {
  cta: JSON
  id: ID
  description: String
  featureId: ID
  isDismissible: Boolean
  meta: JSON
  prereqs: JSON
  profileId: ID
  profileType: String
  sortOrder: Int
  state: Int
  title: String
}

"""Describes a source for points for a set"""
type PointSource {
  """The type of this source."""
  type: ID!

  """The field this source acts on"""
  field: String!

  """The config used to help calculate. Depends on type."""
  config: JSON
}

type ResetAffectedData {
  affectedSetCount: Int
  affectedSets: [Set]
  affectedPhaseGroupCount: Int
}

"""Configure whether a task's CTA should be converted to a page link"""
enum TaskCTAMode {
  """Show the standard CTA for this task, if there is one."""
  STANDARD

  """
  Change the CTA of this task to be a link to the primary page for the entity.
  """
  PAGE_LINK
}

"""DEPRECATED. Use TaskCTAMode instead"""
enum TaskViewFormat {
  """TODO"""
  FULL_TASK

  """TODO"""
  LINKS_ONLY
}

input PhaseGroupPageQuery {
  page: Int
  perPage: Int
  sortBy: String
  entrantIds: [ID]
  filter: PhaseGroupPageQueryFilter
}

input PhaseGroupPageQueryFilter {
  id: [ID]
  waveId: ID
}

type PhaseGroupConnection {
  pageInfo: PageInfo
  nodes: [PhaseGroup]
}

"""Data on phase progression, keyed on destination PhaseId"""
type ProgressionData {
  """Origin phase ID that is the source of this progression."""
  origin: Int

  """Amount of seeds per phase group that are progressing."""
  numProgressing: Int
}

"""Standings Configuration"""
type StandingsConfig {
  id: ID

  """The sorts, or tiebreakers, used to generate standings"""
  standingsSorts: [StandingsSort!]!
}

"""Defines a sort, or tiebreaker, for standings"""
type StandingsSort {
  id: ID
  orderNum: Int
  sortDirection: StandingsSortDirection
  sortType: StandingsSortType

  """StatDefinition of this StandingsSort"""
  statDefinition: StatDefinition
}

"""StandingsSort SortDirection, if required by its SortType"""
enum StandingsSortDirection {
  """"""
  ASC

  """"""
  DESC
}

"""StandingsSort SortType, or tiebreaker type"""
enum StandingsSortType {
  """"""
  STAT

  """"""
  COMPLETION_TIME
}

"""Definition of a stat"""
type StatDefinition {
  id: ID
  abbreviation: String
  aggregationMethod: StatAggregationMethod
  description: String
  displayName: String
  orderNum: Int
  statKey: String
  valueType: StatValueType
}

"""
The method in which stats are aggregated upwards, ie. from the Game to Set level
"""
enum StatAggregationMethod {
  """"""
  SUM

  """"""
  MIN

  """"""
  MAX

  """"""
  AVG
}

"""The ValueType attributed to a StatDefinition"""
enum StatValueType {
  """"""
  NUMBER

  """"""
  DURATION

  """"""
  TEXT

  """"""
  BOOLEAN
}

"""Stats Configuration"""
type StatsConfig {
  id: ID

  """Stat definitions"""
  statDefinitions: [StatDefinition]
}

input SetStateFilter {
  """Type of filter for state, supports values of "exclude" and "include"."""
  type: String!

  """List of states to exclude or include depending on the type setting."""
  states: [ActivityState]
}

type EntrantExpandedName {
  prefix: String
  name: String
}

input EventSeedPageQuery {
  page: Int
  perPage: Int
  filter: EventSeedPageQueryFilter
}

input EventSeedPageQueryFilter {
  name: String
  phaseIds: [ID]
}

type EventSeedConnection {
  pageInfo: PageInfo
  nodes: [EventSeed]
}

"""An event seed in a event"""
type EventSeed {
  """The entrant for this event seed"""
  entrant: Entrant
  id: ID

  """Non-zero error code if an error occurred processing this seed"""
  errorCode: EventSeedErrorCode

  """If true, this seed should not be moved"""
  isLocked: Boolean

  """
  Indicates whether the phase seed is "in limbo". In other words, is the phase seed value currently trustworthy.
  """
  isPendingPhaseSeed: Boolean

  """True if this event seed has been removed from the event"""
  isRemoved: Boolean

  """The phase seed where this event seed starts"""
  originPhaseSeed: Seed

  """The seedNum for this event seed"""
  seedNum: Int
}

"""The error code associated with an EventSeed"""
enum EventSeedErrorCode {
  """"""
  NO_ERROR

  """"""
  GROUP_SEED_NUM_UNAVAILABLE

  """"""
  SEED_RANGE_FULL

  """"""
  GROUP_SEED_NUM_OUTSIDE_RANGE

  """"""
  GROUP_ALREADY_STARTED
}

"""Used to build the frontend navbar for profile navigation"""
type ProfileNavFeature {
  activeState: Int
  badge: Int
  canEdit: Boolean
  count: Int
  events: [ProfileNavFeature]
  icon: String
  isPublished: Boolean
  startAt: Timestamp
  status: String
  subItems: [ProfileNavFeature]
  tab: String
  text: String
  type: String
  url: String
  viewMore: Boolean
}

input EventPhaseGroupPageQuery {
  page: Int
  perPage: Int
  sortBy: String
  filter: EventPhaseGroupPageQueryFilter
}

input EventPhaseGroupPageQueryFilter {
  displayIdentifier: String

  """Array of phaseIds to include in search results"""
  phaseId: [ID] = null
  state: [Int]
}

input EventPhasePageQuery {
  page: Int
  perPage: Int
  sortBy: String
  filter: EventPhasePageQueryFilter
}

input EventPhasePageQueryFilter {
  name: String

  """Array of phaseIds to include in search results"""
  phaseIds: [ID] = null
  state: [Int]
}

type PhaseConnection {
  pageInfo: PageInfo
  nodes: [Phase]
}

input EventRequestQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: EventRequestFilter
}

input EventRequestFilter {
  status: [RequestStatus]

  """Filter on the other type. i.e. requester/recipient"""
  entityType: String

  """Filter on the specific entity. Should also specify entityType"""
  entityId: ID
  location: LocationFilterType
  search: PaginationSearchType
}

"""A ruleset for a videogame"""
type Ruleset {
  id: ID

  """Whether or not duplicate characters are allowed in decks"""
  allowCharacterDupes: Boolean

  """Maximum number of duplicates allowed for any given card in a deck"""
  cardDupeLimit: Int

  """Maximum number of cards allowed in a deck"""
  cardLimit: Int

  """Number of classes a player needs to select"""
  classSelectionCount: Int

  """Maximum number of decks allowed per player"""
  deckLimit: Int

  """Number of decks per class"""
  decksPerClass: Int

  """Description of the Ruleset"""
  description: String

  """Ruleset GameMode enumeration"""
  gameMode: Int

  """Whether or not the Ruleset is the default Ruleset of a Videogame"""
  isDefault: Boolean

  """Maximum number of cards allowed to overlap with other decks"""
  maxOverlap: Int

  """Minimum number of cards required to overlap with primary deck"""
  minOverlapWithPrimary: Int

  """Name of the Ruleset"""
  name: String

  """Whether a primary deck is required or not"""
  requirePrimaryDeck: Boolean

  """Additional Ruleset settings configuration"""
  settings: JSON

  """Ruleset type"""
  type: String

  """Id of the Videogame associated with this Ruleset"""
  videogameId: Int
}

input StandingPaginationQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: StandingPageFilter
}

input StandingPageFilter {
  id: ID
  ids: [ID]
  search: PaginationSearchType
}

input UserLeaguesPaginationQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: UserLeaguesPaginationFilter
}

input UserLeaguesPaginationFilter {
  videogameId: [ID]
  upcoming: Boolean
  past: Boolean
  search: PaginationSearchType
}

"""Publishing settings for a user"""
type UserPublishingSettings {
  birthday: UserBirthdayPublishingState
  location: UserLocationPublishingState
  name: UserNamePublishingState
  profileAuthorizations: UserProfileAuthorizationPublishingSettings
  publishing: ProfilePublishingState
}

"""Publishing settings for a user's birthday"""
enum UserBirthdayPublishingState {
  """"""
  PRIVATE

  """"""
  MONTH_DAY_ONLY

  """"""
  PUBLIC
}

"""Publishing settings for a user's location"""
enum UserLocationPublishingState {
  """"""
  PRIVATE

  """"""
  COUNTRY_ONLY

  """"""
  PUBLIC
}

"""Publishing settings for a user's name"""
enum UserNamePublishingState {
  """"""
  PRIVATE

  """"""
  FIRST_NAME_LAST_INITIAL

  """"""
  PUBLIC
}

"""Publishing settings for a user's profile authorizations"""
type UserProfileAuthorizationPublishingSettings {
  discord: UserProfileAuthorizationPublishState
  displayFirst: AuthorizationType
  mixer: UserProfileAuthorizationPublishState
  twitch: UserProfileAuthorizationPublishState
  twitter: UserProfileAuthorizationPublishState
  xbox: UserProfileAuthorizationPublishState
}

"""Publishing state for a user's profile authorization"""
enum UserProfileAuthorizationPublishState {
  """"""
  PRIVATE

  """"""
  PUBLIC
}

"""A ban or warning as a result of malicious actions"""
type UserPunishment {
  id: ID
  createdAt: Timestamp

  """Employee that created this punishment"""
  createdByUser: User
  expiresAt: Timestamp
  externalNotes: String
  internalNotes: String

  """User getting punished"""
  punishedUser: User
  type: Int
  updatedAt: Timestamp
}

input UserRequestQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: UserRequestFilter
}

input UserRequestFilter {
  status: [RequestStatus]

  """Filter on the other type. i.e. requester/recipient"""
  entityType: String

  """Filter on the specific entity. Should also specify entityType"""
  entityId: ID
  location: LocationFilterType
  search: PaginationSearchType
}

input UserTournamentsPaginationQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: UserTournamentsPaginationFilter
}

input UserTournamentsPaginationFilter {
  past: Boolean
  upcoming: Boolean
  search: PaginationSearchType
  videogameId: [ID]
  tournamentView: String
  excludeId: [ID]
}

"""A user's votes"""
type Votes {
  createdAt: Timestamp
  id: ID
  qty: Int

  """Vote selection"""
  selection: VoteSelection
  selectionId: Int
  sourceId: Int
  sourceType: Int

  """Tournament vote belongs to"""
  tournament: Tournament
  tournamentId: Int
  updatedAt: Timestamp
  userId: Int
  votingEventId: Int
}

"""A vote selection"""
type VoteSelection {
  id: ID
  entityId: Int
  entityType: String
  numVotes: Int

  """Player if entityType is player otherwise null"""
  player: Player
}

"""An email category (announcements, registration, etc.)"""
type EmailCategory {
  id: ID
  description: String
  name: String
}

"""An email type (registration, team invite, marketing, etc.)"""
type EmailType {
  id: ID
  categoryId: Int
  name: String
}

input EntrantPaginationQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: EntrantPageFilter
}

input EntrantPageFilter {
  id: ID
  ids: [ID]
  name: String
  seedless: Boolean
  eventId: ID
  excludedIds: [ID]
  createdSetOnly: Boolean
  eventType: Int
  tournamentId: ID
  search: JSON
  eventIds: [ID]
}

"""Defines paging and filter for Games"""
input PaginatedGamesQuery {
  page: Int
  perPage: Int

  """Supported filter options to filter down Game results"""
  filter: GameFilterType!
}

input GameFilterType {
  """Only return Games for the given Set"""
  setId: ID

  """Only return Games for the given externalId"""
  externalId: String
}

type GameConnection {
  pageInfo: PageInfo
  nodes: [Game]
}

input HubPaginationQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: HubPaginationFilter
}

input HubPaginationFilter {
  search: PaginationSearchType
  isCurrentUserAdmin: Boolean
  includeSuperAdminHubs: Boolean
}

type HubConnection {
  pageInfo: PageInfo
  nodes: [Hub]
}

input LeagueQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: LeaguePageFilter
  sort: TournamentPaginationSort
}

input LeaguePageFilter {
  id: ID
  ids: [ID]

  """ID of the user that owns this league."""
  ownerId: ID
  afterDate: Timestamp
  beforeDate: Timestamp
  computedUpdatedAt: Timestamp
  name: String
  isFeatured: Boolean
  hasBannerImages: Boolean
  activeShops: Boolean
  past: Boolean
  published: Boolean
  publiclySearchable: Boolean
  upcoming: Boolean
  videogameIds: [ID]
}

enum TournamentPaginationSort {
  """"""
  startAt

  """"""
  endAt

  """"""
  eventRegistrationClosesAt

  """"""
  computedUpdatedAt
}

"""A scope that can be requested by an OAuth client/application"""
type AuthScope {
  id: ID
  description: String
  developerDescription: String
}

"""An entity option"""
type Option {
  createdAt: Timestamp
  id: ID
  enabled: Boolean
  entityId: Int
  entityType: String
  fieldType: String
  optionType: String
  required: Boolean
  updatedAt: Timestamp
  visible: Boolean
}

input PlayerQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: PlayerPageFilter
  sort: PlayerPaginationSort
}

input PlayerPageFilter {
  id: ID
  ids: [ID]
  name: String
  gamerTag: String
  searchField: String
  eventId: ID
  isUser: Boolean
  hideTest: Boolean
}

enum PlayerPaginationSort {
  """"""
  id
}

type PlayerConnection {
  pageInfo: PageInfo
  nodes: [Player]
}

"""Normalized profile information."""
type Profile {
  id: ID
  slug: String
  lat: String
  lng: String
  venueAddress: String
  mapsPlaceId: String
  fullAddress: String
  primaryContact: String
  primaryContactType: String

  """Get people in this Profile, filtered by role"""
  people(
    """Which roles to show"""
    roles: [String]

    """Entity type of profile (defaults to tournament)"""
    profileType: String
  ): [User]

  """Get roles for this profile"""
  roles(page: Int, perPage: Int, includeUnconfirmed: Boolean): RoleConnection

  """Build Profile URL"""
  url(
    """tab to add to URL"""
    tab: String

    """
    Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
    """
    relative: Boolean = true
  ): String

  """Tasks for the current user for this profile"""
  userTasks(activeOnly: Boolean = true, limit: Int = null): [Task]

  """Build Profile admin URL"""
  adminUrl(
    """Profile admin tab to add to URL"""
    tab: String

    """
    Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
    """
    relative: Boolean = true
  ): String
}

type ProfileNav {
  profileId: ID
  name: String
  color: String
  images(type: String): [Image]
  topFeatures: [ProfileNavFeatureGroup]
  userFeatures: [ProfileNavFeatureGroup]
  eventDetails: EventDetails
  startAt: Int
  endAt: Int
  hasOnlineEvents: Boolean
  tournamentType: Int
  timezone: String
  city: String
  addrState: String
  countryCode: String
}

"""Used to build the frontend navbar for profile navigation"""
type ProfileNavFeatureGroup {
  navFeatures: [ProfileNavFeature]
  title: String
}

type EventDetails {
  events: [Event]
  total: Int
}

"""layout of widgets on a profile page"""
type ProfileWidgetPageLayout {
  id: String
  config: JSON
  images(type: String): [Image]
  rows: JSON
  version: Int
}

"""A region"""
type Region {
  id: ID
  continent: String
  country: String
  countryCode: String
  defaultTimezone: String
  isEU: Boolean
  region: String
  state: String
  stateLong: String
}

input ScheduleQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: SchedulePaginationFilter
  sort: SchedulePaginationSort
}

input SchedulePaginationFilter {
  past: Boolean
  upcoming: Boolean
  dateRange: DateRangeFilterType
  search: PaginationSearchType
  location: LocationFilterType
  tierIds: [ID]
  eventIds: [ID]
  subleagueIds: [ID]
  videogameId: [ID]
  tournamentView: String
  subLeaderboardId: ID
}

input DateRangeFilterType {
  beforeDate: Timestamp
  afterDate: Timestamp
}

enum SchedulePaginationSort {
  """"""
  startAt

  """"""
  endAt
}

type LegacyScheduleItemConnection {
  pageInfo: PageInfo
  nodes: [LegacyScheduleItem]
}

"""An interface for a type of schedule item"""
interface LegacyScheduleItem {
  name: String
  date: Timestamp
  startAt: Timestamp
  endAt: Timestamp
  state: ActivityState
  type: String
}

"""An entity option selection"""
type Selection {
  id: ID
  createdAt: Timestamp

  """emailTypes for selections"""
  emailTypes: EmailType
  optionId: Int
  selectedByEntity: String
  selectedById: Int
  updatedAt: Timestamp
  valueId: Int

  """values for selections"""
  values: Value
}

"""An entity option value"""
type Value {
  createdAt: Timestamp
  enabled: Boolean
  id: ID
  entityId: Int
  entityType: String
  name: String
  optionId: Int
  updatedAt: Timestamp
  valueType: String
  valueTypeId: Int
  visible: Boolean
}

type SlugAvailability {
  id: ID
  slugState: SlugState
  invalidReason: InvalidSlugReason
  invalidMessage: String
  ownedTournament: Tournament
}

"""Slug availability with regards to ownership"""
enum SlugState {
  """Short slug is available"""
  AVAILABLE

  """Short Slug is unavailable"""
  UNAVAILABLE

  """Short slug can be overwritten by current user"""
  CAN_OVERWRITE

  """Short slug is the same"""
  NO_CHANGE

  """Short slug is unavailable"""
  UNAVAILABLE_UNPUBLISHED

  """Short slug is an invalid string"""
  INVALID
}

"""Reason for invalid short slug"""
enum InvalidSlugReason {
  """Short slug is numerically equal to zero"""
  EQUALS_ZERO

  """Short slug contains whitespace"""
  HAS_WHITESPACE

  """Short slug contains special characters"""
  HAS_SPECIAL_CHARS

  """
  Short slug contains hyphens or underscores not
  								 surrounded by alphanumeric characters
  """
  INVALID_DASHES

  """Short slug is empty"""
  EMPTY_SLUG
}

"""CSV Configuration"""
type CSVConfig {
  """CSV Column Header Info"""
  columnInfo: [CSVColumnInfo]
}

"""CSV Column Info"""
type CSVColumnInfo {
  """Column description"""
  description: String

  """Column required status"""
  isRequired: Boolean

  """Column name"""
  name: String
}

input TeamsPaginationQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: TeamsPageFilter
}

input TeamsPageFilter {
  id: ID
  eventId: ID
  tournamentId: ID
  eventIds: [ID]
  search: JSON
  type: TeamType
  playerId: ID
  videogameId: ID
  memberStatus: [TeamMemberStatus]
  rosterComplete: Boolean
  rosterIncomplete: Boolean
}

"""The type of the team (event or global)"""
enum TeamType {
  """"""
  UNKNOWN

  """"""
  EVENT

  """"""
  OVERALL

  """"""
  EXACT

  """"""
  GLOBAL
}

"""Test"""
type Test {
  """ID"""
  id: ID

  """Private Var"""
  privateVar: String

  """Semi-Private Var"""
  semiPrivateVar: String
}

type TopLevelNav {
  profileId: ID
  name: String
  color: String
  images(type: String): [Image]
}

input TournamentQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: TournamentPageFilter
  sort: TournamentPaginationSort
}

input TournamentPageFilter {
  id: ID
  ids: [ID]

  """ID of the user that owns this tournament."""
  ownerId: ID

  """
  If true, filter to only tournaments the currently authed user is an admin of
  """
  isCurrentUserAdmin: Boolean
  countryCode: String
  addrState: String
  location: TournamentLocationFilter
  afterDate: Timestamp
  beforeDate: Timestamp
  computedUpdatedAt: Timestamp
  name: String
  venueName: String
  isFeatured: Boolean
  isLeague: Boolean
  hasBannerImages: Boolean
  activeShops: Boolean
  regOpen: Boolean
  past: Boolean
  published: Boolean
  publiclySearchable: Boolean
  staffPicks: Boolean
  hasOnlineEvents: Boolean
  topGames: TopGameFilter
  upcoming: Boolean
  videogameIds: [ID]
  sortByScore: Boolean
}

input TournamentLocationFilter {
  """Latitude, Longitude"""
  distanceFrom: String

  """e.g. 50mi"""
  distance: String
}

input TopGameFilter {
  """
  Array of which # top game you want to filter on.e.g. [2, 3] will filter on the 2nd and 3rd top games
  """
  gameNums: [Int]
}

input VideogameQuery {
  page: Int = 1

  """How many nodes to return for the page. Maximum value of 512"""
  perPage: Int = 25
  sortBy: String
  filter: VideogamePageFilter
}

input VideogamePageFilter {
  id: [ID]
  name: String
  forUser: ID
}

type VideogameConnection {
  pageInfo: PageInfo
  nodes: [Videogame]
}

type Mutation {
  acceptAccountInvite(userToken: String, userId: ID, regParams: regParams, updatePlayerParams: updatePlayerParams, msaUserParams: msaUserParams, contactInfoParams: contactInfoParams): User

  """Completes a User Confirmation."""
  confirmUserConfirmation(value: String!, email: String!): UserConfirmation

  """Create an xbox profile authorization given an MSA id token and nonce"""
  connectXboxAccount(idToken: String!, nonce: String!): ProfileAuthorization

  """Create a new oauth application"""
  createAuthClient(data: AuthClientUpdate!): AuthClient

  """Create a new User"""
  createUser(request: createUserRequest!): User

  """Delete an oauth application"""
  deleteAuthClient(id: ID!): Boolean

  """Regenerate an oauth application's secret"""
  regenerateAuthClientSecret(id: ID!): String

  """Reset the password of a user"""
  resetPassword(id: ID, token: String, confirmationId: ID, fields: resetPassword!): User

  """Start the process of making a payment."""
  startStripePayment(
    """The type of entity the user is paying for."""
    entityType: String!

    """The ID of the entity the user is paying for."""
    entityId: ID!

    """The amount of the payment in the currency's smallest unit."""
    amount: Int!

    """The three-letter ISO code of the currency of the payment."""
    currency: String!

    """Client session UUID used to uniquely identify checkout session"""
    sessionId: String!
  ): PaymentIntent

  """Update an oauth application"""
  updateAuthClient(id: ID!, data: AuthClientUpdate!): AuthClient

  """Update a profile request status"""
  updateRequestStatus(id: ID, status: RequestStatus!, hash: String): ProfileRequest

  """Update the amount being charged in a payment intent."""
  updateStripePayment(
    """The type of entity the user is paying for."""
    entityType: String!

    """The ID of the entity the user is paying for."""
    entityId: ID!

    """
    External ID of the payment intent to update (from startStripePayment response)
    """
    externalId: String!

    """The amount of the payment in the currency's smallest unit."""
    amount: Int!
  ): PaymentIntent

  """Upload image"""
  uploadPlayerImage(entityId: ID!, entityType: String!, imageType: String!, file: Upload!, userHash: String, tournamentId: ID): Player

  """Validate user shipping information"""
  validateShippingAddress(fields: ShippingAddress!, shopId: ID!): Address
}

input regParams {
  country: Int
  dob: String
  guardianEmail: String
  password: String
  tos: Boolean
  emailOptOut: Boolean
}

input updatePlayerParams {
  name: String
  gamerTag: String
  prefix: String
  nameDisplay: Int
}

input msaUserParams {
  idToken: String
  nonce: String
  email: String
}

input contactInfoParams {
  nameFirst: String
  nameLast: String
  phoneNumber: String
  birthday: String
  city: String
  countryId: Int
  stateId: Int
  zipcode: String
}

"""An action that requires user confirmation before being taken."""
type UserConfirmation {
  id: ID
  state: UserConfirmationState
  type: Int
  value: String
}

"""The state of a UserConfirmation"""
enum UserConfirmationState {
  """Confirmation has not been verified yet"""
  UNVERIFIED

  """Confirmation has been verified"""
  VERIFIED

  """Confirmation was canceled by user"""
  CANCELED

  """Confirmation has expired"""
  EXPIRED
}

input AuthClientUpdate {
  name: String
  description: String
  redirect_uri: String
  appUrl: String
}

input createUserRequest {
  captcha: String
  email: String!
  password: String!
  dob: String!
  tos: Boolean!
  emailOptOut: Boolean!
  guardianEmail: String
  country: Int!
  language: String
}

input resetPassword {
  id: ID
  email: String
  currPassword: String
  newPassword: String
  confirmPassword: String
  captcha: String
}

"""The information needed to make a payment."""
type PaymentIntent {
  """The ID of the payment intent at the third-party service."""
  externalId: String

  """A client secret, if needed to complete payment."""
  clientSecret: String
}

"""
The `Upload` special type represents a file to be uploaded in the same HTTP request as specified by
 [graphql-multipart-request-spec](https://github.com/jaydenseric/graphql-multipart-request-spec).
"""
scalar Upload

input ShippingAddress {
  overrideAddress: Boolean
  name: String
  address: String
  address2: String
  city: String
  state: String
  zipcode: String
  country: String
}

"""Comparison operator"""
enum Comparator {
  """"""
  GREATER_THAN

  """"""
  GREATER_THAN_OR_EQUAL

  """"""
  EQUAL

  """"""
  LESS_THAN_OR_EQUAL

  """"""
  LESS_THAN
}

"""Content column for image"""
type ImageContentColumn implements ProfileContentColumn {
  caption: String
  colNum: Int
  contentType: String
  value: String
  valueLink: String
}

"""A schedule Item for leagues"""
type LeagueEventScheduleItem implements LegacyScheduleItem {
  """Call to action for a schedule league event"""
  cta: LeagueEventScheduleItemCallToAction
  date: Timestamp
  endAt: Timestamp
  event: Event

  """Max Points for an event"""
  maxPoints: Int
  name: String

  """Total Entrants for an event"""
  numEntrants: Int
  startAt: Timestamp
  state: ActivityState

  """Tier this event is part of"""
  tier: EventTier
  type: String
}

type LeagueEventScheduleItemCallToAction {
  text: String
  url: String
}

"""Content column for markdown"""
type MarkdownContentColumn implements ProfileContentColumn {
  colNum: Int
  contentType: String
  value: String
}

"""
Different options available for verifying player-reported match results
"""
enum MatchConfigVerificationMethod {
  """"""
  TWITCH

  """"""
  STREAM_ME

  """"""
  ANY

  """"""
  MIXER

  """"""
  YOUTUBE
}

"""Monetary prizing information"""
type MonetaryPrizing implements EventPrizing {
  id: ID
  amount: Float
  prizingType: PrizingType
}

"""A schedule item for a phase"""
type PhaseScheduleItem implements LegacyScheduleItem {
  date: Timestamp
  endAt: Timestamp
  event: Event
  name: String
  phase: Phase
  startAt: Timestamp
  state: ActivityState
  type: String
}

"""Product prizing information"""
type ProductPrizing implements EventPrizing {
  id: ID
  claimed: Boolean
  claimedByUser: JSON
  prizingType: PrizingType
  shopProduct: ShopProduct
}

"""Race specific bracket configuration"""
type RaceBracketConfig implements BracketConfig {
  automaticEndTime: Timestamp
  id: ID
  automaticStartTime: Timestamp
  bracketType: BracketType
  goalTargetComparator: Comparator
  goalTargetValue: String
  limitMode: RaceLimitMode
  limitValue: Int
  raceType: RaceType
}

"""Enforces limits on the amount of allowable Race submissions"""
enum RaceLimitMode {
  """"""
  BEST_ALL

  """"""
  FIRST_ALL

  """"""
  PLAYTIME
}

"""Race type"""
enum RaceType {
  """"""
  GOALS

  """"""
  TIMED
}

"""Race specific match configuration"""
type RaceMatchConfig implements MatchConfig {
  id: ID
  bracketType: BracketType

  """Can players report results?"""
  playerReportingEnabled: Boolean

  """Accepted methods of verification that players can use"""
  verificationMethods: [MatchConfigVerificationMethod]

  """Are players required to submit verification of their reported results?"""
  verificationRequired: Boolean
}

"""Content column for schedule"""
type ScheduleContentColumn implements ProfileContentColumn {
  colNum: Int
  contentType: String
  filter: JSON
  label: String
}

"""A set of actions available for a team to take"""
type TeamActionSet implements ActionSet {
  id: ID
  actions(isAllowed: Boolean): [Action]
  addAlternate: Action
  addPlayer: Action
  removeAlternate: Action
  removePlayer: Action
}

"""Content column for video"""
type VideoContentColumn implements ProfileContentColumn {
  caption: JSON
  colNum: Int
  contentType: String
  value: String
}